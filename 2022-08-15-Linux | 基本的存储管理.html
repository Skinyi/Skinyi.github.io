<!DOCTYPE html>
<html  lang="zh-CN,en,default" >
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <title>基本的存储管理 | Avery Ma 的个人网站</title>
    <meta name="description" content="🔴 此文章由之前的 Typora 笔记迁移过来，内容可能已经过时。  添加分区、文件系统和持久挂载 磁盘分区 ​通过创建磁盘分区，管理员可以使用其执行不同功能。在以下情况下，磁盘分区是必要或有益的：  限制应用或用户的可用空间； 将操作系统和程序文件与用户文件分隔开； 创建用于内存交换的单独区域； 限制磁盘空间使用，以提高诊断工具和备份映像的性能。  MBR 分区方案 ​MBR 是一种比较传统">
<meta property="og:type" content="article">
<meta property="og:title" content="基本的存储管理">
<meta property="og:url" content="https://skinyi.github.io/2022-08-15-Linux%20|%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.html">
<meta property="og:site_name" content="Avery Ma 的个人网站">
<meta property="og:description" content="🔴 此文章由之前的 Typora 笔记迁移过来，内容可能已经过时。  添加分区、文件系统和持久挂载 磁盘分区 ​通过创建磁盘分区，管理员可以使用其执行不同功能。在以下情况下，磁盘分区是必要或有益的：  限制应用或用户的可用空间； 将操作系统和程序文件与用户文件分隔开； 创建用于内存交换的单独区域； 限制磁盘空间使用，以提高诊断工具和备份映像的性能。  MBR 分区方案 ​MBR 是一种比较传统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://skinyi.github.io/images/linux/MBR-%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="https://skinyi.github.io/images/linux/GPT-%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png">
<meta property="article:published_time" content="2022-08-15T06:31:35.176Z">
<meta property="article:modified_time" content="2022-08-15T06:40:36.998Z">
<meta property="article:author" content="skinyi">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="RHEL">
<meta property="article:tag" content="RHCE">
<meta property="article:tag" content="认证考试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skinyi.github.io/images/linux/MBR-%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png">

    
    <link rel="icon" href="images/favicon.png" type="image/x-icon">

    
<link rel="stylesheet" href="/css/common.min.css">



    
    
    
    
        <link href="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/css/lightgallery.min.css" rel="stylesheet">
    
    
    
<link rel="stylesheet" href="/css/iconfont.min.css">

    
<meta name="generator" content="Hexo 6.2.0"></head>

    <body>
        <header class="header header-fixture">
    <div class="profile-search-wrap flex sm:block">
        
        
        <div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6">
            <a id="avatar" role="link" href="https://github.com/skinyi" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer" >
                <img src="/images/avatar.jpg" class="rounded-full" alt="avatar">
            </a>
            <h2 id="name" class="hidden lg:block">Avery Ma</h2>
            <h3 id="title" class="hidden xl:block">IT 从业者</h3>
            
            <small id="location" class="hidden lg:block">
                <i class="iconfont icon-map-icon"></i>
                宁夏, 中国
            </small>
            
        </div>
        
        
<div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:w-full">
    <form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200">
        <div class="input-group table bg-gray-100 lg:bg-white w-full">
            <input id="search-input" type="text" placeholder="搜索" class="inline-block w-full bg-gray-100 lg:bg-white">
            <span class="table-cell">
                <button name="search tigger button" disabled>
                    <i class="iconfont icon-search m-2"></i>
                </button>
            </span>
        </div>
    </form>
        
<div id="content-json" data-placeholder="搜索" class="invisible hidden">/content.json</div>
<script id="search-teamplate" type="text/html" data-path="/content.json">
    <div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="搜索" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">{{ title }}</h1>
                <p class="result-content text-gray-600 text-sm">{{{ text }}}</p>
            </a>
            {{/each}}
        </div>
    </div>
</script>

</div>


        <button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false">
            <i class="iconfont icon-hamburger"></i>
        </button>
    </div>
    <nav id="menu-nav" class="hidden sm:flex flex-col">
        
        
            <div class="menu-item menu-home" role="menuitem">
                <a href="/.">
                    <i class="iconfont icon-home" aria-hidden="true"></i>
                    <span class="menu-title">首页</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-archives" role="menuitem">
                <a href="/archives">
                    <i class="iconfont icon-archive" aria-hidden="true"></i>
                    <span class="menu-title">归档</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-categories" role="menuitem">
                <a href="/categories">
                    <i class="iconfont icon-folder" aria-hidden="true"></i>
                    <span class="menu-title">分类</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-tags" role="menuitem">
                <a href="/tags">
                    <i class="iconfont icon-tag" aria-hidden="true"></i>
                    <span class="menu-title">标签</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-repository" role="menuitem">
                <a href="/repository">
                    <i class="iconfont icon-project" aria-hidden="true"></i>
                    <span class="menu-title">项目</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-about" role="menuitem">
                <a href="/about">
                    <i class="iconfont icon-cup" aria-hidden="true"></i>
                    <span class="menu-title">关于</span>
                </a>
            </div>
        
        

    </nav>
</header>

        <section class="main-section">
            
    <main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen">
    

    <article class="content article article-archives article-type-list" itemscope="">
        <header class="article-header">
            
    
        <h1 class="article-title text-lg" itemprop="name">
            基本的存储管理
        </h1>
    



            <p class="article-meta mb-3 text-xs">
                <span class="article-date">
    <i class="iconfont icon-calendar-check"></i>
	<a href="/2022-08-15-Linux%20%7C%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.html" class="article-date">
	  <time datetime="2022-08-15T06:31:35.176Z" itemprop="datePublished">8月 15</time>
	</a>
</span>

                
    <span class="article-category">
    <i class="iconfont icon-folder"></i>
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> , <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/Linux/">Linux</a> , <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a> , <a class="article-category-link" href="/categories/%E8%BF%81%E7%A7%BB%E6%96%87%E7%AB%A0/">迁移文章</a>
  </span>


                
    <span class="article-tags">
    <i class="iconfont icon-tag"></i>
    <a class="article-tag-none-link" href="/tags/Linux/" rel="tag">Linux</a>, <a class="article-tag-none-link" href="/tags/RHCE/" rel="tag">RHCE</a>, <a class="article-tag-none-link" href="/tags/RHEL/" rel="tag">RHEL</a>, <a class="article-tag-none-link" href="/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/" rel="tag">认证考试</a>
  </span>


                
                
    
        <span class="post-wordcount" itemprop="wordCount">字数统计: 4.6k(字)</span>
    
    
        <span class="post-readcount" itemprop="timeRequired">阅读时长: 18(分)</span>
    


            </p>
        </header>
        <div class="marked-body article-body">
            <blockquote>
<p>🔴 此文章由之前的 Typora 笔记迁移过来，内容可能已经过时。</p>
</blockquote>
<h2 id="添加分区、文件系统和持久挂载">添加分区、文件系统和持久挂载</h2>
<h3 id="磁盘分区">磁盘分区</h3>
<p>​通过创建磁盘分区，管理员可以使用其执行不同功能。在以下情况下，磁盘分区是必要或有益的：</p>
<ul>
<li>限制应用或用户的可用空间；</li>
<li>将操作系统和程序文件与用户文件分隔开；</li>
<li>创建用于内存交换的单独区域；</li>
<li>限制磁盘空间使用，以提高诊断工具和备份映像的性能。</li>
</ul>
<h4 id="MBR-分区方案">MBR 分区方案</h4>
<p>​MBR 是一种比较传统的分区方案，其支持最多 4 个主分区。在 Linux 系统上，管理员可以使用 扩展分区和逻辑分区来创建最多 15 个分区。由于分区大小数据以 32 位值存储，使用 MBR 方案分区时，最大磁盘和分区大小为 2TB。</p>
<p><img src="images/linux/MBR-%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png" alt="MBR 分区示例" /></p>
<p>​由于现代存储技术的不断发展，MBR 分区的 2TiB 限制已从理论转化为现在越来越频繁的现实问题，故新的 GUID 分区表（GPT 分区）正在取代 MBR 分区方案。</p>
<h4 id="GPT-分区方案">GPT 分区方案</h4>
<p>​GPT 分区方案依赖于新的固件系统 —— UEFI。GPT 是 UEFI 标准的一部分，可以解决原有基于 MBR 的方案所带来的许多限制。</p>
<p>​GPT 分区方案最多可提供 128 个分区以及 8ZiB（80 亿 TiB）的分区和磁盘。GPT 分区提供了备份副本来确保数据的安全性，且提供了校验算法来检测 GPT 头和分区表中的错误和损坏。</p>
<p><img src="images/linux/GPT-%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png" alt="GPT 分区示例" /></p>
<h4 id="使用-PARTED-管理分区">使用 PARTED 管理分区</h4>
<p>​Parted 分区实用程序同时支持管理 MBR 和 GPT 两种分区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted -h</span></span><br><span class="line">用法: parted [选项]... [设备 [命令 [参数]...]...]</span><br><span class="line">接受以 参数s 执行的 命令s 来管理 设备.  如果未提供任何命令, 将以交互模式运行。</span><br><span class="line"></span><br><span class="line">选项s:</span><br><span class="line">  -h, --<span class="built_in">help</span>                      显示此帮助信息</span><br><span class="line">  -l, --list                      列举所有块设备的分区结构信息</span><br><span class="line">  -m, --machine                   displays machine parseable output</span><br><span class="line">  -s, --script                    never prompts <span class="keyword">for</span> user intervention</span><br><span class="line">  -v, --version                   displays the version</span><br><span class="line">  -a, --align=[none|cyl|min|opt]  alignment <span class="keyword">for</span> new partitions</span><br><span class="line"></span><br><span class="line">命令s:</span><br><span class="line">  align-check TYPE N                       检查分区 N 的对齐类型(min|opt)</span><br><span class="line">  <span class="built_in">help</span> [COMMAND]                           打印通用帮助信息, 或针对 COMMAND 的帮助信息</span><br><span class="line">  mklabel,mktable LABEL-TYPE               创建新的磁盘标签(分区表)</span><br><span class="line">  mkpart PART-TYPE [FS-TYPE] START END     创建新分区</span><br><span class="line">  name NUMBER NAME                         以 NAME 命名分区 NUMBER</span><br><span class="line">  <span class="built_in">print</span> [devices|free|list,all|NUMBER]     显示 分区表|可用设备|空闲空间|所有分区|指定分区                                                (NUMBER) </span><br><span class="line">  quit                                     退出程序</span><br><span class="line">  rescue START END                         恢复在 START 和 END 之间丢失的分区</span><br><span class="line">  resizepart NUMBER END                    重新规划分区 NUMBER 的大小</span><br><span class="line">  <span class="built_in">rm</span> NUMBER                                删除分区 NUMBER</span><br><span class="line">  select DEVICE                            选择要操作的存储设备</span><br><span class="line">  disk_set FLAG STATE                      更改选定设备上的 FLAG 的状态为 STATE</span><br><span class="line">  disk_toggle [FLAG]                       切换选定设备上的 FLAG 的 FLAG 为 STATE</span><br><span class="line">  <span class="built_in">set</span> NUMBER FLAG STATE                    更改分区 NUMBER 上的 FLAG 为状态 STATE</span><br><span class="line">  toggle [NUMBER [FLAG]]                   切换分区 NUMBER 的 FLAG 为 STATE</span><br><span class="line">  unit UNIT                                设置默认单位为 UNIT</span><br><span class="line">  version                                  display the version number and copyright                                                 information of GNU Parted</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，<em>parted</em> 显示以 10 的幂次方表示的所有空间大小（KB、MB、GB）。可以使用 <code>unit</code> 子命令来更改默认设置，该子命令接受以下参数：</p>
<ul>
<li><em>s</em> 表示扇区；</li>
<li><em>B</em> 表示字节；</li>
<li><em>MiB</em>、<em>GiB</em> 或 <em>TiB</em>（2 的幂次方）；</li>
<li><em>MB</em>、<em>GB</em> 或 <em>TB</em> （10 的幂次方）；</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1 unit s print</span></span><br><span class="line">Model: NVMe Device (nvme)</span><br><span class="line">Disk /dev/nvme0n1: 41943040s</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start     End        Size       Type     File system     Flags</span><br><span class="line"> 1      2048s     616447s    614400s    primary  xfs             boot</span><br><span class="line"> 2      616448s   4810751s   4194304s   primary  linux-swap(v1)</span><br><span class="line"> 3      4810752s  41943039s  37132288s  primary  xfs</span><br></pre></td></tr></table></figure>
<h5 id="向新磁盘写入分区表">向新磁盘写入分区表</h5>
<p>​要对新驱动器进行分区，首先必须为其写入磁盘标签。磁盘标签指示了所用的分区方案。</p>
<blockquote>
<p><code>parted</code> 命令的更改是即时生效的，若误用了该命令，注定会导致数据丢失。</p>
</blockquote>
<p>​以 root 用户身份，使用以下命令将 MBR 磁盘标签写入磁盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1 mklabel msdos</span></span><br></pre></td></tr></table></figure>
<p>​若要写入 GPT 磁盘标签，则需使用该命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1 mklabel gpt</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>mklabel 子命令会擦除现有分区表，其效果类似于 windows 中的格式化，仅当重复利用旧磁盘而不保留其中的旧有数据时使用。</p>
</blockquote>
<h5 id="创建-MBR-分区">创建 MBR 分区</h5>
<p>​创建 MBR 磁盘分区包含以下几个步骤：</p>
<ol>
<li>指定要在其上创建分区的磁盘设备。</li>
</ol>
<p>以 root 用户身份执行 <code>parted</code> 命令，并指定该磁盘设备名称作为参数。这样将会以交互模式启动 parted 命令并显示命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1</span></span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/nvme0n1</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 <code>mkpart</code> 子命令创建新的主分区或扩展分区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkpart</span><br><span class="line">Partition <span class="built_in">type</span>? primary/extended? primary    <span class="comment"># 创建主分区</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>若需创建多于四个分区，可以适当将后面的分区创建为扩展分区，并在其上创建逻辑分区。</p>
</blockquote>
<ol start="3">
<li>指示要在分区上创建的文件系统类型，如 <em>xfs</em> 或 <em>ext4</em>，此操作不会在分区上创建文件系统，仅为指示分区类型作用。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File system <span class="built_in">type</span>? [ext2]? xfs    <span class="comment"># xfs </span></span><br></pre></td></tr></table></figure>
<p>​要了解支持哪些文件系统类型，可以使用以下命令进行查询。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1 help mkpart</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>指定磁盘上新分区开始的扇区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start? 2048s    <span class="comment"># 第 2948 个扇区开始</span></span><br></pre></td></tr></table></figure>
<p>​也可以使用 MB、MiB 等单位，默认单位为 MB。程序会自动舍入进行对齐。对于大多数磁盘而言，起始扇区设置为 2048 的倍数较为安全。</p>
<ol start="5">
<li>指定应结束新分区的磁盘扇区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End? 1000MB    <span class="comment"># 分区大小 Size = End - Start</span></span><br></pre></td></tr></table></figure>
<p>​提供了结束位置后，<em>parted</em> 即可利用新分区的详细信息来更新磁盘上的分区表。</p>
<ol start="6">
<li>退出 <em>parted</em>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(parted) quit</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>运行 <code>udevadm settle</code> 命令。此命令会等待系统检测新分区并在 <em>/dev</em> 目录下创建关联的设备文件，完成操作后才会返回。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] udevadm settle</span><br><span class="line">[root@localhost ~]</span><br></pre></td></tr></table></figure>
<p>​上述操作的一条命令版本为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] parted /dev/nvme0n1 mkpart primary xfs 2048s 1000MB</span><br></pre></td></tr></table></figure>
<h5 id="创建-GPT-分区">创建 GPT 分区</h5>
<p>​创建 GPT 磁盘分区包含以下几个步骤：</p>
<ol>
<li>指定要在其上创建分区的磁盘设备。</li>
</ol>
<p>以 root 用户身份执行 <code>parted</code> 命令，并指定该磁盘设备名称作为参数。这样将会以交互模式启动 parted 命令并显示命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1</span></span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/nvme0n1</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 <code>mkpart</code> 子命令创建新的主分区或扩展分区。</li>
</ol>
<p>对于 GPT 方案而言，每个分区都会获得一个名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkpart</span><br><span class="line">Partition name? []? userdata</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指示要在分区上创建的文件系统类型，如 <em>xfs</em> 或 <em>ext4</em>。这并不会在分区上创建文件系统；它仅仅指示分区类型。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File system <span class="built_in">type</span>? [ext2]? xfs</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>指定磁盘上新分区开始的扇区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start? 2048s</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>指定应结束新分区的磁盘扇区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End? 1000MB</span><br></pre></td></tr></table></figure>
<p>​一旦提供了结束位置，parted 即可利用新分区的详细信息来更新磁盘上的分区表。</p>
<ol start="6">
<li>退出 parted。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(parted) quit</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]\<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>运行 <code>udevadm settle</code> 命令。 此命令会等待系统检测新分区并在 <em>/dev</em> 目录下创建关联的设备文件。只有在完成上述操作后，他才返回。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># udevadm settle</span></span><br><span class="line">[root@localhost ~]\<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>​作为交互模式的替代方法，您也可以按如下方式创建分区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1 mkpart userdata xfs 2048s 1000MB</span></span><br></pre></td></tr></table></figure>
<h5 id="删除分区">删除分区</h5>
<p>​以下步骤适用于 MBR 和 GPT 两种分区方案。</p>
<ol>
<li>指定包含要删除的分区的磁盘。</li>
</ol>
<p>作为 root 用户，以磁盘设备作为唯一参数执行 <code>parted</code> 命令，从而通过命令提示符在交互模式下启动 parted。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1</span></span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/nvme0n1</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>确定要删除的分区的分区编号。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(parted) <span class="built_in">print</span></span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/nvme0n1: 5369MB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number    Start    End        Size    File system        Name        Flags</span><br><span class="line">  1        1049kB    1000MB    999MB    xfs                userdata       </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除分区。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parted) <span class="built_in">rm</span> 1</span><br></pre></td></tr></table></figure>
<p>​<code>rm</code> 子命令会立即从磁盘上的分区表中删除该分区。</p>
<ol start="4">
<li>退出 <code>parted</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(parted) quit</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]\<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h5 id="创建文件系统">创建文件系统</h5>
<p>​创建块设备后，下一步是向其中添加文件系统。红帽企业 Linux 支持许多不同的文件系统类型，其中两种常见的类型是 XFS 和 ext4。红帽企业 Linux 的安装程序 Anaconda 默认使用 XFS。</p>
<p>​以 root 用户身份，使用 <code>mkfs.xfs</code> 命令为块设备应用 XFS 文件系统。对于 ext4，可以使用 <code>mkfs .ext4</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># mkfs.xfs /dev/nvme0n1</span></span><br><span class="line">meta-data=/dev/nvme0n1        isize=512    account=4, agsize=60992 blks</span><br><span class="line">         =                    sects=512    attr=2,    projid32bit=1</span><br><span class="line">         =                    crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                    reflink=1</span><br><span class="line">data     =                     bsize=4096  blocks=243968, imaxpct=25</span><br><span class="line">         =                    sunit=0        swidth=0 blks</span><br><span class="line">naming   =version 2            bsize=4096    ascii-ci=0, ftype=1</span><br><span class="line"><span class="built_in">log</span>         =internal <span class="built_in">log</span>        bsize=4096  blocks=1566, version=2</span><br><span class="line">         =                    sectsz=512    sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                extsz=4096  blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>
<h3 id="挂载文件系统">挂载文件系统</h3>
<p>​关于手动挂载文件系统的方法已在 <em>23. 访问 Linux 文件系统</em> 中阐述，本节重点说明持久挂载文件系统。持久挂载是指系统开机或重启进入系统后自动挂载某块设备而无需进行手动挂载，此行为跟图形用户界面中的自动挂载有区别。</p>
<p>​要实现持久化挂载可已修改 <em>/etc/fstab</em> 文件，向其添加新的条目。修改完毕后使用 <code>systemctl daemon-reload</code> 命令来实现修改生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># cat /etc/fstab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Wed Jun  2 22:59:16 2021</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk/&#x27;.</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># After editing this file, run &#x27;systemctl daemon-reload&#x27; to update systemd</span></span><br><span class="line"><span class="comment"># units generated from this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">UUID=360e2f42-d6de-4209-8487-f36b7cc69cc2 /        xfs     defaults        0 0</span><br><span class="line">UUID=529dd49b-7b72-4394-8fbb-98eb7f24de1e /boot    xfs     defaults        0 0</span><br><span class="line">UUID=bb97577f-bf23-4a75-8ff1-46b7dce21eb9 none     swap    defaults        0 0</span><br></pre></td></tr></table></figure>
<p>​fstab 文件的条目的第一个字段指定设备。本示例使用 UUID 来指定设备（推荐）。创建文件系统时会在其超级块中创建和存储 UUID。或者可以使用设备文件。</p>
<blockquote>
<p>列出块设备的 UUID 可以使用 <code>lsblk</code> 或 <code>blkid</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[student@localhost ~]\$ lsblk -fs</span><br><span class="line">NAME      FSTYPE LABEL UUID                                 MOUNTPOINT</span><br><span class="line">sr0                                                         </span><br><span class="line">nvme0n1p1 xfs          529dd49b-7b72-4394-8fbb-98eb7f24de1e /boot</span><br><span class="line">└─nvme0n1                                                   </span><br><span class="line">nvme0n1p2 swap         bb97577f-bf23-4a75-8ff1-46b7dce21eb9 [SWAP]</span><br><span class="line">└─nvme0n1                                                   </span><br><span class="line">nvme0n1p3 xfs          360e2f42-d6de-4209-8487-f36b7cc69cc2 /</span><br><span class="line">└─nvme0n1 </span><br><span class="line">[student@localhost ~]\$ sudo blkid</span><br><span class="line">[sudo] password <span class="keyword">for</span> student: </span><br><span class="line">/dev/nvme0n1: PTUUID=<span class="string">&quot;3c479f3a&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span></span><br><span class="line">/dev/nvme0n1p1: UUID=<span class="string">&quot;529dd49b-7b72-4394-8fbb-98eb7f24de1e&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> PARTUUID=<span class="string">&quot;3c479f3a-01&quot;</span></span><br><span class="line">/dev/nvme0n1p2: UUID=<span class="string">&quot;bb97577f-bf23-4a75-8ff1-46b7dce21eb9&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> PARTUUID=<span class="string">&quot;3c479f3a-02&quot;</span></span><br><span class="line">/dev/nvme0n1p3: UUID=<span class="string">&quot;360e2f42-d6de-4209-8487-f36b7cc69cc2&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> PARTUUID=<span class="string">&quot;3c479f3a-03&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​第二个字段指定挂载点，通过它可以访问目录结构中的块设备，挂载点必须存在于父文件系统中。</p>
<p>​第三个字段包含文件系统类型，如 <em>xfs</em>、<em>ext4</em>、<em>swap</em>（交换分区）等。</p>
<p>​第四个字段的值可以取以逗号分隔的多个应用于设备的选项。常见值的意义如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rw</td>
<td>按可读可写权限挂载。</td>
</tr>
<tr>
<td>suid</td>
<td>允许文件或目录的所属用户位和所属组位生效。</td>
</tr>
<tr>
<td>exec</td>
<td>允许执行二进制程序。</td>
</tr>
<tr>
<td>dev</td>
<td>解释字符或屏蔽特殊设备于文件系统上。</td>
</tr>
<tr>
<td>auto</td>
<td>可以使用 <code>mount -a</code> 手动挂载上。</td>
</tr>
<tr>
<td>nouser</td>
<td>不允许普通用户手动挂载此设备。</td>
</tr>
<tr>
<td>async</td>
<td>异步存储（性能较佳），将内容写入日志在保存到磁盘。</td>
</tr>
<tr>
<td>defaults</td>
<td>以上选项的合集。</td>
</tr>
</tbody>
</table>
<p>​第五个字段的值表示 ”指定分区是否被 <code>dump</code> 程序备份“，0 代表不备份，1 代表备份，2 代表不定期备份。</p>
<p>​第六个字段的值表示 ”指定分区是否被 <code>fsck</code> 程序检测“, 0 代表不检测，其他数字代表检测的优先级，递增优先级越低。</p>
<blockquote>
<p>添加新条目于 <em>/etc/fstab</em> 中后需使用 <code>mount -a</code> 选项来测试下挂载是否成功，确保无误后再重启测试（有可能会导致系统无法启动）。</p>
<p>修改完 <em>/etc/fstab</em> 中的条目需使用 <code>mount -o remount</code> 命令来重新挂载（<code>mount -a</code> 命令对已挂载上的同名设备不会重新挂载）。</p>
</blockquote>
<h2 id="管理交换空间">管理交换空间</h2>
<p>​交换空间是受 Linux 内核内存管理子系统控制的磁盘区域。内核通过使用交换空间将不活动的内存页暂存在交换空间中来节省 RAM，交换空间一般以磁盘分区的形式存在，称为 <em>交换分区</em>。系统内存和交换分区组合在一起称为虚拟内存。由于交换分区位于磁盘上，其读取和写入速度较慢。</p>
<p>​关于交换分区的划定大小有下表的建议：</p>
<table>
<thead>
<tr>
<th>RAM</th>
<th>交换分区大小</th>
<th>允许休眠功能时的交换内存大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>2GiB 或 以下</td>
<td>RAM 大小 x 2</td>
<td>RAM 大小 x 3</td>
</tr>
<tr>
<td>介于 2GiB 和 8GiB 之间</td>
<td>与 RAM 大小 相同</td>
<td>RAM 大小 x 2</td>
</tr>
<tr>
<td>介于 8GiB 和 64GiB 之间</td>
<td>至少 4GiB</td>
<td>RAM 大小 x 1.5</td>
</tr>
<tr>
<td>64 GiB 以上</td>
<td>至少 4GiB</td>
<td>不建议开启休眠功能</td>
</tr>
</tbody>
</table>
<p>​休眠：指关闭计算机电源之前将内存内容转储到交换分区（注意：硬盘是非易失性存储设备），重新打开计算机后系统会从交换分区中恢复内存上的内容，无需完全启动。</p>
<h3 id="创建交换空间">创建交换空间</h3>
<p>​创建交换空间的基本操作可概述为：创建文件系统类型为 linux-swap 的分区、为设备放置交换签名。</p>
<p>​以前 <code>parted</code> 工具可以根据分区文件系统类型来确定是否应激活设备，但现在即使该程序不再使用分区文件系统类型，设置此类型也可以使管理员快速确定该分区的用途。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># parted /dev/nvme0n1</span></span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/nvme0n1</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">&#x27;help&#x27;</span> to view a list of commands.</span><br><span class="line">(parted) <span class="built_in">print</span></span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/nvme0n1: 5369MB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number    Start    End        Size    File system        Name    Flags</span><br><span class="line">  1        1049kB    1001MB    1000MB                    data</span><br><span class="line"></span><br><span class="line">(parted) mkpart</span><br><span class="line">Partition name? []? swap1</span><br><span class="line">File system <span class="built_in">type</span>? [ext2]? linux-swap</span><br><span class="line">Start? 1001MB</span><br><span class="line">End? 1257MB</span><br><span class="line">(parted) <span class="built_in">print</span></span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/nvme0n1: 5369MB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number    Start    End        Size    File system        Name    Flags</span><br><span class="line">  1        1049kB    1001MB    1000MB                    data</span><br><span class="line">  2        1001MB    1257MB    256MB    linux-swap(v1)    swap</span><br><span class="line"></span><br><span class="line">(parted) quit</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]\<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>​创建分区后，运行 <code>udevadm settle</code> 命令。此命令会等待系统检测新分区并在 <em>/dev</em> 中创建关联的设备文件。只有在完成上述操作后，它才返回。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># udevadm settle</span></span><br><span class="line">[root@localhost ~]\<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h4 id="格式化设备">格式化设备</h4>
<p>​<code>mkswap</code> 命令向设备应用交换签名。与其他格式化实用程序不同，<code>mkswap</code> 在设备开头写入单个数据块，而将设备的其余部分保留为未格式化，这样内核就可以使用它来存储内存页。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># mkswap /dev/nvme0n1</span></span><br><span class="line">Setting up swapspace version 1, size = 244 MiB(255848448 bytes) no label, UUID=39e2667a-9458-42fe-9665-c5c854605881</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="激活交换空间">激活交换空间</h4>
<p>​可以使用 swapon 命令激活已格式化的交换空间。</p>
<p>​使用 <code>swapon</code> 并将设备作为参数，或者使用 <code>swapon -a</code> 来激活 <em>/etc/fstab</em> 文件中列出的所有交换空间。使用 <code>swapon --show</code> 和 <code>free</code> 命令检查可用的交换空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># free</span></span><br><span class="line">        total    used    free    shared    buff/cache    available</span><br><span class="line">Mem:    1873036    134688    1536436    16748    201912        1576044</span><br><span class="line">Swap:    0        0        0</span><br><span class="line">[root@localhost ~]\<span class="comment"># swapon /dev/nvme0n1</span></span><br><span class="line">[root@localhost ~]\<span class="comment"># free</span></span><br><span class="line">        total    used    free    shared    buff/cache    available</span><br><span class="line">Mem:     1873036 135044    1536040    16748    201952        1575690</span><br><span class="line">Swap:    249852    0        249852</span><br></pre></td></tr></table></figure>
<p>​可以使用 swapoff 命令停用交换空间。如果交换空间具有写入的页面，swapoff 会尝试将这些页面移动到其他活动交换空间或将其写回到内存中。如果无法将数据写入到其他位置，则 <code>swapoff</code> 命令会失败，并显示错误，而交换空间仍保持活动。</p>
<h4 id="持久激活交换空间">持久激活交换空间</h4>
<p>​要想在每次启动时都激活交换空间，请在 <em>/etc/fstab</em> 文件中放置一个条目。基于上面创建的交换空间，以下示例显示了 <em>/etc/fstab</em> 中比较典型的一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=39e2667a-9458-42fe-9665-c5c854605881    swap    swap    defaults    0    0</span><br></pre></td></tr></table></figure>
<p>​该示例使用 UUID 作为第一个字段。格式化设备时，<code>mkswap</code> 命令会显示该 UUID。如果丢失了 <code>mkswap</code> 的输出，请使用 <code>lsblk --fs</code> 命令。作为替代方法，您也可以在第一个字段中使用设备名称。</p>
<p>​第二个字段通常为 mount point 保留。但是，由于交换设备无法通过目录结构访问，因此该字段取占位符值为 <em>swap</em> 或者 <em>none</em>。</p>
<p>​第三个字段是文件系统类型。交换空间的文件系统类型是 <em>swap</em>。</p>
<p>​第四个字段是选项，本示例中使用了 <em>defaults</em> 选项，关于此选项的介绍可以参见上文。</p>
<p>​最后两个字段是 <em>dump</em> 标志和 <em>fsck</em> 顺序，这两个字段的值默认为 0 就行。</p>
<p>​在 /etc/fstab 文件中添加或删除条目时，可以运行 <code>systemctl daemon-reload</code> 命令或重启服务器，以便让 systemd 注册新配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]\<span class="comment"># systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>
<h4 id="设置交换空间优先级">设置交换空间优先级</h4>
<p>​默认情况下，系统会按顺序使用交换空间，即内核先使用第一个已激活交换空间，直至其空间已满，然后开始使用第二个交换空间。不过，您也可以为每个交换空间定义一个优先级，从而强制按该顺序使用交换空间。</p>
<p>​要设置优先级，请在 <em>/etc/fstab</em> 中使用 <em>pri</em> 选项。内核会首先使用优先级最高的交换空间。默认优先级为 -2。</p>
<p>​以下示例显示了 <em>/etc/fstab</em> 中定义的三个交换空间。内核首先使用最后一个条目，其优先级为 <em>pri=10</em>。当该空间已满时，他将使用第二个条目，其优先级为 <em>pri=4</em>。最后，它将使用第一个条目，其默认优先级为 -2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UUID=a2345678-9458-42fe-9665-c5c854605881    swap    swap    defaults    0    0</span><br><span class="line">UUID=b3245c23-9458-42fe-9665-c5c854605881    swap    swap    defaults    0    0</span><br><span class="line">UUID=39e2667a-9458-42fe-9665-c5c854605881    swap    swap    defaults    0    0</span><br></pre></td></tr></table></figure>
<p>​使用 swapon --show 可以显示交换空间的优先级。</p>
<p>​当交换空间具有相同的优先级时，内核会以轮询方式向其中写入。</p>

        </div>
        
<blockquote class="copyright">
    <p><strong>本文链接 : </strong><a class="permalink" href="https://skinyi.github.io/2022-08-15-Linux%20|%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.html">https://skinyi.github.io/2022-08-15-Linux | 基本的存储管理.html</a></p>
    <p><strong>这篇文章由作者胡编乱造或者由其他文章复制粘贴而来，其中有些内容可能已经过时，请谨慎参考复制文章中的内容。</strong></p>
</blockquote>


    </article>
    
    <section id="comments">
        
    </section>


    

</main>


<aside style="" id="sidebar" class="aside aside-fixture">
    <div class="toc-sidebar">
        <nav id="toc" class="article-toc">
            <h3 class="toc-title">文章目录</h3>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%86%E5%8C%BA%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%8C%81%E4%B9%85%E6%8C%82%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">添加分区、文件系统和持久挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">磁盘分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MBR-%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">MBR 分区方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GPT-%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">GPT 分区方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PARTED-%E7%AE%A1%E7%90%86%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用 PARTED 管理分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E6%96%B0%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">向新磁盘写入分区表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-MBR-%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">创建 MBR 分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-GPT-%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">创建 GPT 分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">删除分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">创建文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">挂载文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">管理交换空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.</span> <span class="toc-text">创建交换空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AE%BE%E5%A4%87"><span class="toc-number">2.1.1.</span> <span class="toc-text">格式化设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.2.</span> <span class="toc-text">激活交换空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%BF%80%E6%B4%BB%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.3.</span> <span class="toc-text">持久激活交换空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.1.4.</span> <span class="toc-text">设置交换空间优先级</span></a></li></ol></li></ol></li></ol>
        </nav>
    </div>
</aside>





        </section>
        <footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 bg-gray-100 z-40">
    
    
        <p class="footer-custom">❤ Powered by <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a> with <a href="https://github.com/fengkx/hexo-theme-purer" target="_blank" rel="noopener noreferrer">Purer theme</a>.</p>
    
</footer>

        <div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div>
        <div id="search-view-container" class="hidden shadow-xl"></div>
        
<script src="/js/dom-event.min.js"></script>



<script src="/js/local-search.min.js"></script>



    <script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script>
    
<script src="/js/light-gallery.min.js"></script>






    </body>
</html>
