{"meta":{"title":"Avery Ma 的个人网站","subtitle":"这是什么？","description":"个人网站、博客","author":"skinyi","url":"https://skinyi.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-02-22T12:55:00.000Z","updated":"2022-02-24T13:30:42.633Z","comments":true,"path":"about/index.html","permalink":"https://skinyi.github.io/about/index.html","excerpt":"","text":"关于我 联系我 邮箱：averyma@foxmail.com"},{"title":"categories","date":"2022-02-23T06:19:06.228Z","updated":"2022-02-23T06:19:06.228Z","comments":false,"path":"categories/index.html","permalink":"https://skinyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"repositories","date":"2022-02-23T06:19:12.138Z","updated":"2022-02-23T06:19:12.138Z","comments":false,"path":"repository/index.html","permalink":"https://skinyi.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-23T06:19:18.235Z","updated":"2022-02-23T06:19:18.235Z","comments":false,"path":"tags/index.html","permalink":"https://skinyi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二二年四月一日新交规记分","slug":"驾驶 | 二二年四月一日新交规记分","date":"2022-04-18T02:31:41.767Z","updated":"2022-04-18T04:42:00.651Z","comments":true,"path":"2022-04-18-驾驶 | 二二年四月一日新交规记分.html","link":"","permalink":"https://skinyi.github.io/2022-04-18-%E9%A9%BE%E9%A9%B6%20|%20%E4%BA%8C%E4%BA%8C%E5%B9%B4%E5%9B%9B%E6%9C%88%E4%B8%80%E6%97%A5%E6%96%B0%E4%BA%A4%E8%A7%84%E8%AE%B0%E5%88%86.html","excerpt":"","text":"引用来源 以下内容引用总结自从 2022 年 4 月 1 日起施行《道路交通安全违法行为记分管理办法》（公安部令第163号）。 记分规定 记十二分的相关情形 饮酒后驾驶机动车的； 造成致人轻伤以上或者死亡的交通事故后逃逸，尚不构成犯罪的； 使用伪造、变造的机动车号牌、行驶证、驾驶证、校车标牌或者使用其他机动车号牌、行驶证的； 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数百分之二十以上，或者驾驶其他载客汽车载人超过核定人数百分之百以上的； 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速百分之二十以上，或者驾驶其他机动车在高速公路、城市快速路上行驶超过规定时速百分之五十以上的； 驾驶机动车在高速公路、城市快速路上倒车、逆行、穿越中央分隔带掉头的； 代替实际机动车驾驶人接受交通违法行为处罚和记分牟取经济利益的。 记九分的相关情形 驾驶 7 座以上载客汽车载人超过核定人数百分之五十以上未达到百分之百的； 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的； 驾驶机动车在高速公路或者城市快速路上违法停车的； 驾驶未悬挂机动车号牌或者故意遮挡、污损机动车号牌的机动车上道路行驶的； 驾驶与准驾车型不符的机动车的； 未取得校车驾驶资格驾驶校车的； 连续驾驶中型以上载客汽车、危险物品运输车辆超过 4 小时未停车休息或者停车休息时间少于 20 分钟的。 记六分的相关情形 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数未达到百分之二十，或者驾驶 7 座以上载客汽车载人超过核定人数百分之二十以上未达到百分之五十，或者驾驶其他载客汽车载人超过核定人数百分之五十以上未达到百分之百的； 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速未达到百分之二十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的； 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路上行驶超过规定时速百分之二十以上未达到百分之五十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的； 驾驶载货汽车载物超过最大允许总质量百分之五十以上的； 驾驶机动车载运爆炸物品、易燃易爆化学物品以及剧毒、放射性等危险物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志并采取必要的安全措施的； 驾驶机动车运载超限的不可解体的物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志的； 驾驶机动车运输危险化学品，未经批准进入危险化学品运输车辆限制通行的区域的； 驾驶机动车不按交通信号灯指示通行的； 机动车驾驶证被暂扣或者扣留期间驾驶机动车的； 造成致人轻微伤或者财产损失的交通事故后逃逸，尚不构成犯罪的； 驾驶机动车在高速公路或者城市快速路上违法占用应急车道行驶的。 记三分的相关情形 驾驶校车、公路客运汽车、旅游客运汽车、7 座以上载客汽车以外的其他载客汽车载人超过核定人数百分之二十以上未达到百分之五十的； 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的； 驾驶机动车在高速公路或者城市快速路上不按规定车道行驶的； 驾驶机动车不按规定超车、让行，或者在高速公路、城市快速路以外的道路上逆行的； 驾驶机动车遇前方机动车停车排队或者缓慢行驶时，借道超车或者占用对面车道、穿插等候车辆的； 驾驶机动车有拨打、接听手持电话等妨碍安全驾驶的行为的； 驾驶机动车行经人行横道不按规定减速、停车、避让行人的； 驾驶机动车不按规定避让校车的； 驾驶载货汽车载物超过最大允许总质量百分之三十以上未达到百分之五十的，或者违反规定载客的； 驾驶不按规定安装机动车号牌的机动车上道路行驶的； 在道路上车辆发生故障、事故停车后，不按规定使用灯光或者设置警告标志的； 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆上道路行驶； 驾驶校车上道路行驶前，未对校车车况是否符合安全技术要求进行检查，或者驾驶存在安全隐患的校车上道路行驶的； 连续驾驶载货汽车超过 4 小时未停车休息或者停车休息时间少于 20 分钟的； 驾驶机动车在高速公路上行驶低于规定最低时速的。 记一分的相关情形 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之十以上未达到百分之二十的； 驾驶机动车不按规定会车，或者在高速公路、城市快速路以外的道路上不按规定倒车、掉头的； 驾驶机动车不按规定使用灯光的； 驾驶机动车违反禁令标志、禁止标线指示的； 驾驶机动车载货长度、宽度、高度超过规定的； 驾驶载货汽车载物超过最大允许总质量未达到百分之三十的； 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆以外的机动车上道路行驶的； 驾驶擅自改变已登记的结构、构造或者特征的载货汽车上道路行驶的； 驾驶机动车在道路上行驶时，机动车驾驶人未按规定系安全带的； 驾驶摩托车，不戴安全头盔的。 记分对照记忆表 超员 以下车型分类统一归类为以下简称： 大车：校车、公路客运汽车、旅游客运汽车； 中车：7 座以上载客汽车； 小车：除了以上类别的其他载客机动车。 车型\\程度 20% 以下 20% 到 50% 50% 到 100% 100% 以上 大车 6 12 12 12 中车 6 9 12 小车 3 6 12 超速 表格中标黑的表示在高速、城市快速路上行驶的情形，未标黑表示在普通公路上行驶的情形。以下车型分类统一归类为以下简称： 大车：校车、中型以上载客载货汽车、危险物品运输车辆； 小车：除了以上类别的其他载客机动车。 车型\\程度 10% 到 20% 20% 到 50% 50% 到 100% 100% 以上 大车 1，6 6，12 9，12 9，12 小车 3，6 6，12 6，12 超重 车型\\程度 30% 以下 30% 到 50% 50% 以上 载货汽车 1 3 6","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"生活","slug":"生活","permalink":"https://skinyi.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"驾驶","slug":"生活/驾驶","permalink":"https://skinyi.github.io/categories/%E7%94%9F%E6%B4%BB/%E9%A9%BE%E9%A9%B6/"}],"tags":[{"name":"记分","slug":"记分","permalink":"https://skinyi.github.io/tags/%E8%AE%B0%E5%88%86/"},{"name":"驾照","slug":"驾照","permalink":"https://skinyi.github.io/tags/%E9%A9%BE%E7%85%A7/"},{"name":"开车","slug":"开车","permalink":"https://skinyi.github.io/tags/%E5%BC%80%E8%BD%A6/"},{"name":"法律法规","slug":"法律法规","permalink":"https://skinyi.github.io/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"}]},{"title":"重学 Shell 编程之 Linux 三剑客","slug":"Shell | 重学 Shell 编程之 Linux 三剑客","date":"2022-04-07T06:08:05.796Z","updated":"2022-04-27T02:16:11.820Z","comments":true,"path":"2022-04-07-Shell | 重学 Shell 编程之 Linux 三剑客.html","link":"","permalink":"https://skinyi.github.io/2022-04-07-Shell%20|%20%E9%87%8D%E5%AD%A6%20Shell%20%E7%BC%96%E7%A8%8B%E4%B9%8B%20Linux%20%E4%B8%89%E5%89%91%E5%AE%A2.html","excerpt":"","text":"正则表达式 RegExp 一个在线图形化解释正则表达式的工具网站。支持正则表达式的 linux 命令主要有：grep、sed、awk、find、expr等。正则表达式一般以一系列格式控制字符来匹配具有特定规律和意义的字符串，如电话号码、电子邮件地址等。 正则语法速查表： 符号 支持的语法 描述 归类 开始、结束匹配控制 ^ Basic RegExp 表示以它后面的表达式开头才匹配 $ Basic RegExp 表示以它前面的表达式结尾才匹配 归类 一些特殊字符的意义 . Basic RegExp 表示匹配任意一个字符（不匹配 \\n、\\r） ? Extended RegExp 表示起一个表达式匹配零次或一次 * Basic RegExp 表示前一个表达式匹配零次或多次 + Extended RegExp 表示前一个表达式匹配一次或多次 | Extended RegExp 表示在其分隔的两个表达式之间进行选择 \\ 表示将下个字符进行转义 () Extended RegExp 标记一个子表达式的开始和结束 [] Basic RegExp 标记一个中括号表达式的开始和结束 {} Extended RegExp 标记限定符表达式的开始和结束 归类 Basic RegExp 除 * + ? 的限定符，n 取非负整数 {n} Extended RegExp 表示精确匹配 n 次 {n,} Extended RegExp 表示最少匹配 n 次 {n,m} Extended RegExp n&lt;m，表示匹配 n 到 m 次 归类 [] 限定的普通字符 [anychars] Basic RegExp 表示匹配其中列举的任一字符 [^anychars] Basic RegExp 表示匹配除了其中列举的任意字符 [A-Z] Basic RegExp 表示匹配所有大写字母中的一个 归类 常见转义字符 \\s\\S Basic RegExp \\s 匹配所有空白字符、\\S 匹配所有非空白字符 \\w Basic RegExp 相当于 [A-Za-z0-9]，匹配大写字母、小写字母或 0 到 9 中的一个 \\d Basic RegExp 匹配 0 到 9 中的一个数 \\t Basic RegExp 匹配一个制表符 \\v Basic RegExp 匹配一个垂直制表符 \\r Basic RegExp 匹配一个回车符 \\f Basic RegExp 匹配一个换页符 * 和 + 限定符都是贪婪的，即会尽可能多的匹配字符（最长子串），在它们后面加上 ？限定符并指定使用 Perl 正则模式实现非贪婪或最小字串匹配。 特殊符号要匹配本身，需进行转义。 使用 grep + 正则查找文件内容 1234567891011121314151617grep, egrep, fgrep - 打印匹配给定模式的行# 用法格式grep [options] PATTERN [FILE...]grep [options] [-e PATTERN | -f FILE] [FILE...]# 常见选项-A NUM, --after-context=NUM # 打印出匹配的行之后的下文 NUM 行 -B NUM, --before-context=NUM # 打印出匹配的行之前的上文 NUM 行-C NUM, --context=NUM # 打印除匹配行之前和之后的上下文 NUM 行-c NUM, --count # 打印出匹配的数量而不是匹配的内容，配合 -v 为不匹配的数量-E, --extended-regexp # 使用拓展正则进行解释匹配-P, --perl-regexp # 使用 perl 正则进行解释匹配-o, --only-matching # 只显示匹配中的行中与模式相匹配的部分-v, --invert-match # 只选择不匹配的行（反选）-w, --word-regexp # 只选择含有能组成完整的词的匹配的行。判断方法是匹配的子字符串必须是一行的开始，# 或者是在一个不可能是词的组成的字符之后。与此相似，它必须是一行的结束，或者是# 在一个不可能是词的组成的字符之前。词的组成字符是字母，数字，还有下划线。 🟢grep 默认支持 Basic RegExp 语法，可以通过传递选项 -E 以支持扩展正则表达式语法（相当于 egrep 命令）或 -P 以支持 Perl 语言的正则表达式语法。 123456789101112131415# 测试文件内容[skinyi@fedora ~]$ cat -n lyrics.txt 1 Fly me to the moon 2 3 Fly me to the mo0n 4 And let me play @mong the stars 5 (I want you)Let me see what Spring is like 0n Jupiter and Mars 6 In other words,hold my hand 7 _In other words,darling,kiss me 8 Fill m9 heart with song 9 And 1et me sing forever more10 (Because)You are all I long for All I worship and adOre11 in other words,please be true12 in other words,I love you13 12345678910111213# 过滤空行 -v 反选 -n 输出行号[skinyi@fedora ~]$ grep -nv &#x27;^$&#x27; lyrics.txt 1:Fly me to the moon3:Fly me to the mo0n4:And let me play @mong the stars5:(I want you)Let me see what Spring is like 0n Jupiter and Mars6:In other words,hold my hand7:_In other words,darling,kiss me8:Fill m9 heart with song9:And 1et me sing forever more10:(Because)You are all I long for All I worship and adOre11:in other words,please be true12:in other words,I love you 12345678910111213# 去掉以某个字符开头的行（常用来去注释）[skinyi@fedora ~]$ grep -nv &#x27;^(&#x27; lyrics.txt 1:Fly me to the moon2:3:Fly me to the mo0n4:And let me play @mong the stars6:In other words,hold my hand7:_In other words,darling,kiss me8:Fill m9 heart with song9:And 1et me sing forever more11:in other words,please be true12:in other words,I love you13: 1234567# 匹配以 i 开头，e 结尾的最短子串，-P 指定使用 perl 语言的正则语法，支持非贪婪写法[skinyi@fedora ~]$ egrep -no &#x27;^i.+?e&#x27; lyrics.txt # 不能达到目的 11:in other words,please be true12:in other words,I love[skinyi@fedora ~]$ grep -no -P &#x27;^i.+?e&#x27; lyrics.txt # 可达到目的 11:in othe12:in othe 使用 sed 命令流式的处理文本文件 sed -r 支持扩展正则。Sed是一个流式编辑器。流式编辑器是用来在输入流（一个文件或者管道输入）中完成基本文本转换的工具。 sed 命令会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令的执行过程如下： 每次读取一行内容； 根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据； 将执行结果输出； 当一行数据匹配完成后，它会继续读取下一行数据，并重复 1-3 的过程，直到将文件中所有行的数据处理完毕。 123456789sed - 文本筛选和格式转换的流式编辑器# 用法格式sed [选项]... &#123;脚本（若没有其他脚本）&#125; [输入文件]...# 常见选项-e 脚本, --expression=脚本 # 添加 脚本 到程序的处理工作流列表-f 脚本文件, --file=脚本文件 # 添加 脚本文件 到程序的处理工作流列表-i [扩展名], --in-place[=扩展名] # 直接修改文件（如果指定拓展名则备份文件）-E, -r, --regexp-extended # 在脚本模式中使用拓展正则-n, --quiet, --silent # 取消自动打印模式空间 12345678910111213141516171819# 测试文本[skinyi@fedora ~]$ cat -n lyrics.txt 1 My whole world changed from the moment I met you 2 And it would never be the same 3 Felt like I knew that I always loved you 4 From the moment I heard your name 5 6 Everything was perfect, I knew this love was worth it 7 Our own miracle in the making 8 And till this world stops turning 9 I’ll still be here waiting and waiting to make that vow that I’ll... 10 11 I’ll be by your side 12 Till the day I die 13 I’ll be waiting till I hear you say I do 14 Something old, something new 15 Something borrowed, something blue 16 I’ll be waiting till I hear you say I do 17 打印内容 sed 命令实现文件内容打印采用的基本格式为：[address][/&#123;front-&#125;pattern/,/&#123;back-pattern/&#125;]p。其中 address 表示指定要操作的具体行，2 条斜线内实现指定模式内容的打印，3 条斜线分隔且包围的可指定一定范围的内容的查找（若后模式无法匹配则会一直打印到文件末尾）。 123456# 查找 met 和 name 之间的内容[skinyi@fedora ~]$ sed -nr &#x27;/\\smet\\s/,/\\sname\\s?/p&#x27; lyrics.txt My whole world changed from the moment I met youAnd it would never be the sameFelt like I knew that I always loved youFrom the moment I heard your name 1234567# 不显示空行和以 I 开头的行，常用来进行配置文件的过滤（I 替为 #）[skinyi@fedora ~]$ sed -nr &#x27;/^$|I/!p&#x27; lyrics.txt And it would never be the sameOur own miracle in the makingAnd till this world stops turningSomething old, something newSomething borrowed, something blue 🔴注意：! 代表执行反操作，比如 !p 代表匹配的内容不打印（不匹配的打印），!d 代表匹配的内容不删除（不匹配的删除）。 查找并替换 sed 命令实现文件内容查找并替换采用的基本格式为：[address]s/pattern/replacement/flags。其中： address 表示指定要操作的具体行； pattern 指的是需要替换的内容； replacement 指的是要替换的新内容； flags 用来实现一些特定功能。 flags 标记 功能 n n 为 1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记 g 对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A p 会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用 w file 将缓冲区中的内容写到指定的 file 文件中 &amp; 用正则表达式匹配的内容进行替换 \\n 匹配第 n 个子串，该子串之前在 pattern 中用 () 指定 \\ 转义（转义替换部分包含：&amp;、\\ 等） 12345678910# 将所有出现的 do 替换为 will（不修改源文件）并比较[skinyi@fedora ~]$ sed &#x27;s/do/will/g&#x27; lyrics.txt | colordiff lyrics.txt -13c13&lt; I’ll be waiting till I hear you say I do---&gt; I’ll be waiting till I hear you say I will16c16&lt; I’ll be waiting till I hear you say I do---&gt; I’ll be waiting till I hear you say I will 123# 将第 4 行的 heard 改为 knew 并仅输出修改的行（不修改源文件）[skinyi@fedora ~]$ sed -n &#x27;4s/heard/knew/p&#x27; lyrics.txtFrom the moment I knew your name 123# 将第 13 行的第三个 I 改为 we 并仅输出修改的行（不修改源文件）[skinyi@fedora ~]$ sed -n &#x27;13s/I/we/3p&#x27; lyrics.txtI’ll be waiting till I hear you say we do 🔵注意：匹配模式字符串包含 / 时需要进行转义。 案例：仅打印网卡 ens160 的 ip 12[skinyi@fedora gh-pages]$ ip addr show ens160 | sed -nr &#x27;4s#(^.*t )(.*)(/.*$)#\\2#gp&#x27; # \\2 表示第二组192.168.30.128 删除文件中的特定行（单行或连续行） sed 命令实现删除文件中的特定行的基本格式为：[address]d，其中 address 表示指定要操作的具体行，当不指定地址时代表删除所有行。 以下例子还是以上述 lyrics.txt 文件为范例。 123# 删除所有行（仅在缓冲区）[skinyi@fedora ~]$ sed &#x27;d&#x27; lyrics.txt[skinyi@fedora ~]$ 1234# 删除第 12 行（仅在缓冲区）[skinyi@fedora ~]$ sed &#x27;12d&#x27; lyrics.txt | cdiff lyrics.txt - # alias cdiff=&#x27;colordiff&#x27;，下同12d11&lt; Till the day I die 123456# 删除第 11 到 13 行（仅在缓冲区）[skinyi@fedora ~]$ sed &#x27;11,13d&#x27; lyrics.txt | cdiff lyrics.txt -11,13d10&lt; I’ll be by your side&lt; Till the day I die&lt; I’ll be waiting till I hear you say I do 1234567891011# 删除第 10 行到最后一行（仅在缓冲区）[skinyi@fedora ~]$ sed &#x27;10,$d&#x27; lyrics.txt | cdiff lyrics.txt - # $代表最后一行的行号10,17d9&lt; &lt; I’ll be by your side&lt; Till the day I die&lt; I’ll be waiting till I hear you say I do&lt; Something old, something new&lt; Something borrowed, something blue&lt; I’ll be waiting till I hear you say I do&lt; 增加内容（以行为单位） sed 命令实现文件中增加特定内容行的基本格式为：sed [address]&#123;a|n&#125;\\new_content，其中 a 代表向指定位置后面插入内容、i 代表向指定位置前面插入内容、address 表示指定要操作的具体行，不指定则在每行前面或后面添加内容。 123456789101112# 给每行后面添加 ----------------------------------------------------（仅在缓冲区），并查看前 10 行[skinyi@fedora ~]$ sed &#x27;a\\-------------------------------------------------&#x27; lyrics.txt | head -10My whole world changed from the moment I met you-------------------------------------------------And it would never be the same-------------------------------------------------Felt like I knew that I always loved you-------------------------------------------------From the moment I heard your name-------------------------------------------------------------------------------------------------- 1234567# 给第 1 行前增加 911 - I Do（仅在缓冲区），并查看前 5 行[skinyi@fedora ~]$ sed &#x27;1i\\911 - I Do&#x27; lyrics.txt | head -5911 - I DoMy whole world changed from the moment I met youAnd it would never be the sameFelt like I knew that I always loved youFrom the moment I heard your name 1234567# 添加多行可以使用 \\n 转义字符，效果如下：[skinyi@fedora ~]$ sed &#x27;1i\\I Do\\n911&#x27; lyrics.txt | head -5I Do911My whole world changed from the moment I met youAnd it would never be the sameFelt like I knew that I always loved you 替换整行 sed 命令实现文件中替换某行的内容的基本格式为：sed [address]c\\new_content，其中 address 表示指定要操作的具体行，不指定则会将每行的内容都替换成新行。 12345# 更改首行内容为 Your partial heart got broken from the moment you left me（仅在缓冲区）并查看前三行[skinyi@fedora ~]$ sed &#x27;1c\\Your partial heart got broken from the moment you left me&#x27; lyrics.txt | head -3Your partial heart got broken from the moment you left meAnd it would never be the sameFelt like I knew that I always loved you 使用 awk 实现文本扫描处理 AWK 是一门实现文本扫描与处理的编程语言，常用来实现文本过滤、统计、计算等。awk 将文本文件按照指定（或默认）的分隔符抽象成一个不太严格的表格（每列不一定等长），继而实现对文本的精确处理，awk 抽象和表格的对应关系如下： 表格概念 awk 中的概念 awk 默认分隔符 awk 内置变量及作用 行 Row 记录 Record 换行 \\n NR 指定记录号 列 Column 字段 Feild 空白字符 \\s NF 获取列数 12345678# 用法格式awk - pattern scanning and processing languageawk [ options ] -f program-file [ -- ] file ...awk [ options ] [ -- ] program-text file ...## awk 程序中的 BEGIN&#123;&#125;、END&#123;&#125; 分别控制读取文件之前和读取文件结束的过程。# 常见选项-v var=new_var # 修改 awk 内置变量的取值，如：-v OFS=:（打印字段时以冒号分隔）-F fs, --field-separator fs # 指定 fs 作为每列的分隔符，相当于 -v FS=fs。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Shell","slug":"学习/Shell","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Shell/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://skinyi.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"https://skinyi.github.io/tags/Bash/"},{"name":"脚本编程","slug":"脚本编程","permalink":"https://skinyi.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"}]},{"title":"重学 Shell 编程之基础回顾（三）","slug":"Shell | 重学 Shell 编程之基础回顾（三）","date":"2022-04-01T06:40:56.259Z","updated":"2022-04-07T05:59:22.604Z","comments":true,"path":"2022-04-01-Shell | 重学 Shell 编程之基础回顾（三）.html","link":"","permalink":"https://skinyi.github.io/2022-04-01-Shell%20|%20%E9%87%8D%E5%AD%A6%20Shell%20%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%89%EF%BC%89.html","excerpt":"","text":"Shell 条件测试 条件测试只会得到真与假两种结果，常与 if 判断语句结合进行具有一定复杂逻辑的工作。以下是 shell 条件测试中一些比较常用的语法： 条件测试返回 0 时表示真，返回其他非 0 值时表示假，跟其他编程语言不一致！ 语法 描述 test &lt;测试表达式&gt; 利用 test 命令进行条件测试，注意 test 命令和参数之间存在空格 [ &lt;测试表达式&gt; ] 推荐。等价于上条语法，注意左右中括号和表达式之间存在空格 [[ &lt;测试表达式&gt; ]] 扩展语法，较新，部分解释器可能不支持，注意左右双中括号和表达式之间存在空格 ((&lt;测试表达式&gt;)) 一般用于 if 语句，左右双小括号和表达式之间可以不存在空格 test &lt;测试表达式&gt; 和 [ &lt;测试表达式&gt; ] 语法 这两种语法需要记忆一些涉及文件、逻辑判断使用的特殊选项符号，将其整理如下： 文件测试语法 文件测试语法 描述 归类 文件存在、类型判断 -e pathname 当由 pathname 指定的文件或目录存在时返回真 -s filename 当 filename 存在并且文件大小大于 0 时返回真 -f filename 当 filename 存在并且是常规文件时返回真 -d pathname 当 pathname 存在并且是一个目录时返回真 -b filename 当 filename 存在并且是块文件时返回真 -c filename 当 filename 存在并且是字符文件时返回真 -S filename 当 filename 存在并且是 socket 时返回真 -p filename 当 filename 存在并且是命名管道时返回真 -h filename 当 filename 存在并且是符号链接文件时返回真 (或 -L filename) -t fd 当 fd 是与终端设备相关联的文件描述符时返回真 归类 文件权限位判断 -r pathname 当由 pathname 指定的文件或目录存在并且可读时返回真 -w pathname 当由 pathname 指定的文件或目录存在并且可写时返回真 -x pathname 当由 pathname 指定的文件或目录存在并且可执行时返回真 -u pathname 当由 pathname 指定的文件或目录存在并且设置了 SUID 位时返回真 -g pathname 当由 pathname 指定的文件或目录存在并且设置了 SGID 位时返回真 -k pathname 当由 pathname 指定的文件或目录存在并且设置了&quot;粘滞&quot;位时返回真 -O pathname 当由 pathname 存在并且被当前进程的有效用户 id 的用户拥有时返回真(字母 O 大写) -G pathname 当由 pathname 存在并且属于当前进程的有效用户 id 的用户的用户组时返回真 归类 两个文件的比较 file1 -nt file2 file1 比 file2 新时返回真 file1 -ot file2 file1 比 file2 旧时返回真 file1 -ef file2 file1 和 file2 是同一个文件的硬链接时返回真 逻辑测试语法 逻辑测试语法 描述 -a 逻辑与，操作符两边均为真，结果为真，否则为假。 -o 逻辑非，操作符两边一边为真，结果为真，否则为假。 ! 取非，条件为假，结果为真。 常见字符串测试语法 常见字符串测试语法 描述 -z string 字符串 string 为空串(长度为0)时返回真 -n string 字符串 string 为非空串时返回真 str1 = str2 字符串 str1 和字符串 str2 相等时返回真 str1 == str2 同 = str1 != str2 字符串 str1 和字符串 str2 不相等时返回真 str1 &lt; str2 按字典顺序排序，字符串 str1 在字符串 str2 之前 str1 &gt; str2 按字典顺序排序，字符串 str1 在字符串 str2 之后 常见数值测试语法 常见数值测试语法 描述 int1 -eq int2 如果 int1 等于 int2，则返回真 int1 -ne int2 如果 int1 不等于 int2，则返回真 int1 -lt int2 如果 int1 小于 int2，则返回真 int1 -le int2 如果 int1 小于等于 int2，则返回真 int1 -gt int2 如果 int1 大于 int2，则返回真 int1 -ge int2 如果 int1 大于等于 int2，则返回真 单中括号语法引用变量除了要使用 $ 符号还需要用引号将变量括起来。 [[ &lt;测试表达式&gt; ]] 语法 大部分情形下，双中括号语法与 test 和单中括号语法通用，但是仍存在以下区别： 逻辑测试 [[ &lt;测试表达式&gt; ]] 语法中使用 &amp;&amp;、|| 表示逻辑与和逻辑非，但在 [ &lt;测试表达式&gt; ] 语法中使用 -a 和 -o 运算符。 通配符和正则 [[ &lt;测试表达式&gt; ]] 语法中支持使用通配符和正则表达式。 字符串 [[ &lt;测试表达式&gt; ]] 语法中匹配字符串或通配符不需要引号括起来。 ((&lt;测试表达式&gt;)) 语法 ((&lt;测试表达式&gt;)) 只支持算术运算比较。 案例：判断磁盘是否挂载且挂载点对当前用户是否可读可写 check_disk.sh123456789#!/bin/shdev_name=&quot;sdb1&quot;dev_path=&quot;/dev/$dev_name&quot;mnt_path=&quot;/mnt/data&quot;if [ -b &quot;$dev_path&quot; -a -r &quot;$mnt_path&quot; -a -w &quot;$mnt_path&quot; ]; then echo &quot;磁盘 $dev_path 已挂载且当前用户可读写！&quot;else echo &quot;磁盘未挂载或对当前用户不可读或不可写！&quot;fi Shell 分支语句结构 if 判断语句 if 语句支持单分支和多分支选择结构，单/双分支语句的一般格式是： 12345if 条件; then 条件为真执行的语句else 条件为假执行的语句 # 单分支时不用 else 的部分fi 对于多分支： 123456789if 条件1; then 条件1成立时执行的语句elif 条件2; then 条件2成立时执行的语句elif 条件n; then 条件n成立时执行的语句else 以上条件都不成立时执行的语句fi 与其他编程语言类似，条件判断语句中可以使用 break 关键字进行跳出。 案例：编写脚本监测可用剩余内存并发邮件报警 要求： 当内存可用大小小于 100m 时发邮件进行报警； 将脚本加入 crontab 任务，定时每 30 分钟执行一次。 check_mem.sh123456#!/bin/shmem_free=`free -m|awk &#x27;NR==2 &#123;print $NF&#125;&#x27;`if test $mem_free -lt &#x27;100&#x27;; then local msg=&quot;当前可用内存为 $&#123;mem_free&#125;m，已不足 100m！&quot; echo msg | mail -s &#x27;服务器内存告警&#x27; user@mailsrv.comfi 执行 crontab -e，写入定时任务： 1* /30 * * * * /bin/bash /path/to/scripts/check_mem.sh case in 判断语句 Case in 语句一般用于多分支且判断条件较简单的分支语句结构。Case in 语句的一般格式是： 12345678910111213case 表达式 in 匹配模式1) 匹配模式1成立时执行的语句 ;; 匹配模式2) 匹配模式2成立时执行的语句 ;; 匹配模式n) 匹配模式n成立时执行的语句 ;; *) 其他匹配模式都不成立时执行的语句esac 其中，表达式既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到表达式的值就可以；匹配模式可以是一个数字、一个字符串，甚至是一个简单的正则表达式；;; 的作用相当于其他编程语言的 case 语句中的 break；*) 的作用相当于其他编程语言的 case 语句中的 default。 案例：模拟实现服务启停、重启、查询的管理脚本 service.sh12345678910111213141516171819#!/bin/shcase $1 in start) echo &quot;服务启动成功！&quot; ;; stop) echo &quot;服务停止成功！&quot; ;; restart) echo &quot;重启服务成功！&quot; ;; status) echo &quot;呃。。。。。。&quot; ;; *) echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot; exit 1esacexit 0 Shell 循环语句结构 for 循环 12345# list 是一个列表，可以是数字或字符串序列，元素之间用空格隔开for $variable in &#123;list&#125; # 或 &#123;start..end..step&#125;，如 &#123;1..100..2&#125;表示从1都100，每次自增 2 do do_something...done 类似 C 语言： 1234for (( expression1;expression2;expression3 ))do do_something...done 例子： 123456789101112131415161718192021# 循环列表for i in 1 2 3 4 5 6 7 8do echo $idone# 循环序列，自定义步长for i in &#123;1..10..2&#125;do echo $idone# 类似 C 语言for (( i=1;i&lt;10;++i ))do echo $idone# 遍历数组array=(1 2 3 4 5) # 定义数组for i in $&#123;array[*]&#125;do echo $idone while 循环 1234while [表达式]do do_something...done until 循环 1234until [表达式]do do_something...done 循环结构也可以使用 break,continue 关键字进行逻辑控制。 函数 基本格式： 12345678910111213141516171819# 定义函数，function、return 关键字可省略 ## 标准写法function func_name()&#123; do_something... return ret_val&#125;## 省略花括号function func_name( do_something... return ret_val)## 一般写法func_name()&#123; do_something... retuen ret_val&#125;# 调用函数，其中 arg1 arg2 ... argN 都是参数func_name arg1 arg2 ... argN# 必须先定义再调用 在日常工作中，一把将 shell 的函数定义和函数调用分布在两个脚本文件中，此行为有点类似 C 语言编程中设置头文件的行为，其初衷是模块化编程。 def_func.sh1234function my_func()&#123; echo &quot;单独定义的函数。&quot; return 0&#125; 调用独立定义的函数： exec_func.sh123456#!/bin/shfunc_path=&quot;/path/to/def_func.sh&quot;# 判断函数文件是否存在[ -f func_path ] &amp;&amp; . func_path || &#123;echo &quot;找不到文件：$func_path&quot; 2&gt;&amp;1; exit 1&#125;# 调用函数my_func 函数内部也有一些特殊变量，可进行传递的参数等的处理，可参考调用 shell 脚本时内部的特殊变量，脚本的特殊变量不会被函数内部自动继承，需要层层传递。 调试 shell 脚本 利用 bash -x 显示脚本执行过程 12345678910111213141516171819202122232425[skinyi@fedora ~]$ bash -x check_website_status.sh baidu.com+ req_url=+ req_timeout=5+ req_fails=0+ req_alert_fails=10+ req_wait_time=1+ check_parameters baidu.com+ &#x27;[&#x27; 1 -ne 1 &#x27;]&#x27;+ req_url=baidu.com+ check_status+ true+ curl --head --connect-timeout 5 -s -f baidu.com -o /dev/null+ &#x27;[&#x27; 0 -ne 0 &#x27;]&#x27;++ date --rfc-3339=seconds+ local &#x27;date=2022-04-07 13:43:55+08:00&#x27;+ echo &#x27;2022-04-07 13:43:55 时进行了一次成功的请求&#x27;2022-04-07 13:43:55 时进行了一次成功的请求+ sleep 1+ true+ curl --head --connect-timeout 5 -s -f baidu.com -o /dev/null+ &#x27;[&#x27; 0 -ne 0 &#x27;]&#x27;++ date --rfc-3339=seconds+ local &#x27;date=2022-04-07 13:43:56+08:00&#x27;+ echo &#x27;2022-04-07 13:43:56 时进行了一次成功的请求&#x27;2022-04-07 13:43:56 时进行了一次成功的请求 使用 set -x 和 set +x 包围要调试的代码块 1234567891011[skinyi@fedora ~]$ cat more_than_3.sh #!/bin/shstr_count=0for word in $@;do set -x if [ `expr length $word` -gt 3 ]; then let str_count+=1 fi set +xdoneecho &quot;大于 3 的拼音/单词个数为：$str_count&quot; 执行脚本： 1234567891011121314151617181920212223242526272829[skinyi@fedora ~]$ ./more_than_3.sh ni bu shi zhen zheng de kuai le++ expr length ni+ &#x27;[&#x27; 2 -gt 3 &#x27;]&#x27;+ set +x++ expr length bu+ &#x27;[&#x27; 2 -gt 3 &#x27;]&#x27;+ set +x++ expr length shi+ &#x27;[&#x27; 3 -gt 3 &#x27;]&#x27;+ set +x++ expr length zhen+ &#x27;[&#x27; 4 -gt 3 &#x27;]&#x27;+ let str_count+=1+ set +x++ expr length zheng+ &#x27;[&#x27; 5 -gt 3 &#x27;]&#x27;+ let str_count+=1+ set +x++ expr length de+ &#x27;[&#x27; 2 -gt 3 &#x27;]&#x27;+ set +x++ expr length kuai+ &#x27;[&#x27; 4 -gt 3 &#x27;]&#x27;+ let str_count+=1+ set +x++ expr length le+ &#x27;[&#x27; 2 -gt 3 &#x27;]&#x27;+ set +x大于 3 的拼音/单词个数为：3","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Shell","slug":"学习/Shell","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Shell/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://skinyi.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"https://skinyi.github.io/tags/Bash/"},{"name":"脚本编程","slug":"脚本编程","permalink":"https://skinyi.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"}]},{"title":"重学 Shell 编程之基础回顾（二）","slug":"Shell | 重学 Shell 编程之基础回顾（二）","date":"2022-03-30T08:03:08.891Z","updated":"2022-04-07T02:26:16.026Z","comments":true,"path":"2022-03-30-Shell | 重学 Shell 编程之基础回顾（二）.html","link":"","permalink":"https://skinyi.github.io/2022-03-30-Shell%20|%20%E9%87%8D%E5%AD%A6%20Shell%20%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89.html","excerpt":"","text":"引用命令的结果 `command` $(command) 例： 1234[skinyi@fedora ~]$ echo &quot;当前日期是：`date`&quot;当前日期是：2022年 03月 31日 星期四 11:13:50 CST[skinyi@fedora ~]$ echo &quot;当前用户的 id 是：$(id -u)&quot;当前用户的 id 是：1000 Shell 运算符 Shell 和其它编程语言不同，Shell 不能直接进行算数运算，必须使用数学计算命令。以下是 Shell 中使用的算数运算符： Shell 算数运算符 意义（带 * 代表常用） +、- 加法（或正号）、减法（或负号） * *、/、% 乘法、除法、取余（取模） * ** 幂运算 * ++、-- 自增、自减 * !、&amp;&amp;、|| 逻辑非（取反）、逻辑与（and）、逻辑或（or） * &lt;、&lt;=、&gt;、&gt;= 小于、小于等于、大于、大于等于 ==、!=、= 相等、不等、对于字符串 = 也可表示相当于 * &lt;&lt;、&gt;&gt; 左移位、右移位 ~、|、&amp;、^ 按位取反、按位异或、按位与、按位或 =、+=、-=、*=、/=、%= 赋值运算符，a+=1 相当于 a=a+1，后面类推 * 要想让数学计算发挥作用，必须使用数学计算命令，Shell 中常用的数学计算命令如下表所示。 Shell 运算操作符与运算命令 意义 (()) 用于整数运算的常用运算符，效率很高 let 用于整数运算，类似于”(())“ expr 可用于整数运算，但还有很多其他的额外功能 bc Linux 下的一个计算器程序（适合整数及小数运算） $[] 用于整数运算 awk awk 既可以用于整数运算，也可以用于小数运算 declare 定义变量值和属性，-i 参数可以用于定义整型变量，做运算 (()) 运算符 用法示例： 123456789101112131415161718# 定义变量：[skinyi@fedora ~]$ i=1# 错误示例：[skinyi@fedora ~]$ i=((i+1));echo $ibash: 未预期的符号“(”附近有语法错误[skinyi@fedora ~]$ echo ((i+1))bash: 未预期的符号“(”附近有语法错误# 正确示例：[skinyi@fedora ~]$ i=$((i+1));echo $i2[skinyi@fedora ~]$ ((i=i+1));echo $i3[skinyi@fedora ~]$ i=$((i&gt;1));echo $i1[skinyi@fedora ~]$ ((i=i&gt;1));echo $i0[skinyi@fedora ~]$ echo $((i&lt;1))1 总结： 内部赋值（不直接引用）：((var=表达式))； 外部赋值（直接引用）：var=$((表达式))、echo $((表达式))。 let 指令 用法示例： 1234567891011121314# 正确示例：[skinyi@fedora ~]$ let num=1+1; echo $num2[skinyi@fedora ~]$ let num=num+2; echo $num4[skinyi@fedora ~]$ let num+=2; echo $num6# 错误示例：[skinyi@fedora ~]$ let num=2&gt;1; echo $num2 # 无法根据比较结果赋值[skinyi@fedora ~]$ let num**2; echo $num2 # 只能是以赋值的形式进行计算[skinyi@fedora ~]$ let num=$((2&gt;1)); echo $num1 # 仅用双括号就能实现效果，用 let 冗余 案例：监测网站服务的存活状态 以下示例展示了一个简单的网站服务存活检测的脚本，其原理是对网站定时发送 head 请求以确认网站服务可用，当请求失败次数达到一定次数后给当前系统用户发送邮件告知网站服务出了问题并退出脚本的执行。要想再严格些可以考虑认为一定周期内达到最大失败次数才认为网站挂了，还有在脚本传参时可以进行 url 格式的正则检查，当然这里只是个小案例，主要还是将之前学到的没学到的东西都用了一遍，加深记忆。 check_website_status.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sh## Check web service statusreq_url=&#x27;&#x27; # 请求的网址 urlreq_timeout=&#x27;5&#x27; # 请求超时时间req_fails=&#x27;0&#x27; # 最大尝试请求次数req_alert_fails=&#x27;10&#x27; # 触发报警的最大尝试次数req_wait_time=&#x27;1&#x27; # 每次请求间隔时间check_parameters()&#123; if [ $# -ne 1 ]; then printf &quot;错误：未指定或指定了多个参数！\\n用法：$0 &lt;url&gt;\\n&quot; 2&gt;&amp;1 exit 1 else req_url=$1 fi&#125;send_mail_alert()&#123; if [ $req_fails -ge $req_alert_fails ]; then local mail_message=&quot;自脚本启动以来共发生了$&#123;req_fails&#125;次失败的请求，已达最大失败上限，请及时进行人工检查处理。\\n&quot; echo -e $mail_message | mail -s &quot;警告：你的网站服务可能已经不可用&quot; $USER exit 0 # 发送邮件后就退出，防止邮件轰炸 fi&#125;check_status()&#123; while true; do local date=`date --rfc-3339=seconds` # 使用 head 请求来进行网站是否存活检测 curl --head --connect-timeout $&#123;req_timeout&#125; -s -f $&#123;req_url&#125; -o /dev/null # 若命令返回非 0 则表明请求失败 if [ $? -ne 0 ]; then let req_fails+=1 # 请求失败次数自增 echo &quot;$&#123;date%+*&#125; 时进行了一次失败的请求&quot; send_mail_alert # 调用报警判断是否报警 else echo &quot;$&#123;date%+*&#125; 时进行了一次成功的请求&quot; fi # 每次请求间隔一段时间 sleep $req_wait_time done&#125;check_parameters $@ # 函数不会继承 shell 脚本的参数，调用时需进行传参check_status expr 命令 使用 expr --help 命令查看 expr 命令帮助信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[skinyi@fedora ~]$ expr --help用法：expr 表达式 或：expr 选项 --help 显示此帮助信息并退出 --version 显示版本信息并退出将表达式的值列印到标准输出，分隔符下面的空行可提升算式优先级。可用的表达式有： ARG1 | ARG2 若ARG1 的值不为 0 或者为空，则返回 ARG1，否则返回 ARG2 ARG1 &amp; ARG2 若两边的值都不为 0 或为空，则返回 ARG1，否则返回 0 ARG1 &lt; ARG2 ARG1 小于 ARG2 ARG1 &lt;= ARG2 ARG1 小于或等于 ARG2 ARG1 = ARG2 ARG1 等于 ARG2 ARG1 != ARG2 ARG1 不等于 ARG2 ARG1 &gt;= ARG2 ARG1 大于或等于 ARG2 ARG1 &gt; ARG2 ARG1 大于 ARG2 ARG1 + ARG2 计算 ARG1 与 ARG2 相加之和 ARG1 - ARG2 计算 ARG1 与 ARG2 相减之差 ARG1 * ARG2 计算 ARG1 与 ARG2 相乘之积 ARG1 / ARG2 计算 ARG1 与 ARG2 相除之商 ARG1 % ARG2 计算 ARG1 与 ARG2 相除之余数 字符串 : 表达式 定位字符串中匹配表达式的模式 match 字符串 表达式 等于&quot;字符串 : 表达式&quot; substr 字符串 偏移量 长度 替换字符串的子串，偏移的数值从 1 起计 index 字符串 字符 在字符串中发现字符的地方建立下标，或者标0 length 字符串 字符串的长度 + 记号 将给定记号解析为字符串，即使它是一个类似 “match”或运算符&quot;/&quot;那样的关键字 ( 表达式 ) 给定&lt;表达式&gt;的值请注意有许多运算操作符都可能需要由 shell 先实施转义。如果参与运算的 ARG 自变量都是数字，比较符就会被视作数学符号，否则就是多义的。模式匹配会返回&quot;\\&quot;和&quot;\\&quot;之间被匹配的子字符串或空(null)；如果未使用&quot;\\&quot;和&quot;\\&quot;，则会返回匹配字符数量或是 0。若表达式的值既不是空也不是 0，退出状态值为 0；若表达式的值为空或为 0，退出状态值为 1。如果表达式的句法无效，则会在出错时返回退出状态值 3。 用法示例： 123456789101112131415161718192021222324252627# 使用时最好都进行转义防止与 shell 特殊含义符号冲突[skinyi@fedora ~]$ expr 1 + 34[skinyi@fedora ~]$ expr 2 \\* 36[skinyi@fedora ~]$ expr 2 * 3expr: 语法错误：未预期的参数[skinyi@fedora ~]$ expr 2 \\+ 57# expr match 模式匹配，输出匹配字符个数[skinyi@fedora ~]$ expr .bashrc.d \\: &quot;.*&quot;9[skinyi@fedora ~]$ expr match .bashrc.d &quot;.*\\.d&quot;9[skinyi@fedora ~]$ expr .bashrc.d \\: &quot;.*b&quot;2[skinyi@fedora ~]$ expr .bashrc.d \\: &quot;.*p&quot;0[skinyi@fedora ~]$ expr match zhiyaoniqingqingyixiao wodexinjiumizui0[skinyi@fedora ~]$ expr match zhiyaoniqingqingyixiao zhiyaoni8[skinyi@fedora ~]$ expr match zhiyaoniqingqingyixiao zhini0# expr length 获取字符串长度[skinyi@fedora ~]$ expr length 1234567899 案例：参数传入一个文件的名字，判断其是否是 mp3 文件 check_mp3.sh123#!/bin/sh# &amp;&amp; 分隔的两条语句前面的执行成功（退出码为 0）后才执行后面的语句，||反之expr &quot;$1&quot; &quot;:&quot; &quot;.*\\.mp3\\$&quot; 2&gt;&gt;/dev/null &amp;&amp; echo &quot;这是个 mp3 文件&quot; || echo &quot;这不是 mp3 文件&quot; 案例：参数传入一句话（拼音或单词），判断其长度大于 3 的拼音、单词个数 count_more_than_3.sh12345678#!/bin/shstr_count=0for word in $@; do if [ `expr length $word` -gt 3 ]; then let str_count+=1 fidoneecho &quot;大于 3 的拼音/单词个数为：$str_count&quot; bc 命令 bc 命令默认是以交互模式运行的，即执行 bc 命令会直接进入交互模式，用户可以输入表达式进行计算并得到结果，可以使用管道来传递单个表达式进行计算。bc 同时支持整数和小数计算。 用法示例： 1234[skinyi@fedora ~]$ echo 4.0/2.0 | bc2[skinyi@fedora ~]$ echo 9/3 | bc3 案例：计算 1 到 100 的和 1234567891011#!/bin/sh# echo &#123;1..100&#125; 会打印以空格作为分隔符的 1 到 100 的数字# tr 命令：用于转换或删除文件中的字符，`tr &#x27; &#x27; &#x27;+&#x27;` 代表将输入中的空格转换为 + 再输出echo &quot;1 到 100 的和是 $(echo &#123;1..100&#125; | tr &#x27; &#x27; &#x27;+&#x27; | bc)。&quot;# 或者# seq 用于生成序列，-s 选项指定分隔符为 +echo &quot;1 到 100 的和是 seq -s &#x27;+&#x27; 100 | bc。&quot;# 使用双括号echo &quot;1 到 100 的和是 $((`seq -s &#x27;+&#x27; 100`))。&quot;# 使用 expr，注意这次的分隔符echo &quot;1 到 100 的和是 $(seq -s &#x27; + &#x27; 100 | xargs expr)。&quot; awk 命令 用法示例： 123456[skinyi@fedora ~]$ echo &quot;4.2 2.4&quot; | awk &#x27;&#123;print $1+$2&#125;&#x27;6.6[skinyi@fedora ~]$ echo &quot;4.2 2.4&quot; | awk &#x27;&#123;print $1*$2&#125;&#x27;10.08[skinyi@fedora ~]$ echo &quot;4.2 2.4&quot; | awk &#x27;&#123;print $1+4*$2&#125;&#x27;13.8 $[表达式] $[表达式] 仅能用于整数运算，用法示例： 1234567[skinyi@fedora ~]$ echo $[2**2]4[skinyi@fedora ~]$ echo $[2+2+2]6[skinyi@fedora ~]$ num=5[skinyi@fedora ~]$ echo $[num+2+2]9 read 指令 read 指令用于从标准输入设备中读取输入。 12345678910111213141516171819202122232425262728293031323334[skinyi@fedora ~]$ read --helpread: read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t 超时] [-u 文件描述符] [名称 ...] 从标准输入读取一行并将其分为不同的域。 从标准输入读取单独的一行，或者如果使用了 -u 选项，从文件描述符 FD 中读取。 该行被分割成域，如同词语分割一样，并且第一个词被赋值给第一个 NAME 变量，第二 个词被赋值给第二个 NAME 变量，如此继续，直到剩下所有的词被赋值给最后一个 NAME 变量。只有 $IFS 变量中的字符被认作是词语分隔符。 如果没有提供 NAME 变量，则读取的行被存放在 REPLY 变量中。 选项： -a array 将词语赋值给 ARRAY 数组变量的序列下标成员，从零开始 -d delim 持续读取直到读入 DELIM 变量中的第一个字符，而不是换行符 -e 使用 Readline 获取行 -i text 使用 TEXT 文本作为 Readline 的初始文字 -n nchars 读取 nchars 个字符之后返回，而不是等到读取换行符。 但是分隔符仍然有效，如果遇到分隔符之前读取了不足 nchars 个字符。 -N nchars 在准确读取了 nchars 个字符之后返回，除非遇到文件结束符或者读超时， 任何的分隔符都被忽略 -p prompt 在尝试读取之前输出 PROMPT 提示符并且不带 换行符 -r 不允许反斜杠转义任何字符 -s 不回显终端的任何输入 -t timeout 如果在 TIMEOUT 秒内没有读取一个完整的行则超时并且返回失败。 TMOUT 变量的值是默认的超时时间。TIMEOUT 可以是小数。 如果 TIMEOUT 是 0，那么仅当在指定的文件描述符上输入有效的时候， read 才返回成功；否则它将立刻返回而不尝试读取任何数据。 如果超过了超时时间，则返回状态码大于 128 -u fd 从文件描述符 FD 中读取，而不是标准输入 退出状态： 返回码为零，除非遇到了文件结束符、读超时（且返回码不大于128）、 出现了变量赋值错误或者无效的文件描述符作为参数传递给了 -u 选项。 用法示例： 123456789101112[skinyi@fedora ~]$ read -p &quot;给你五秒时间输入你的名字：&quot; -t 5 name给你五秒时间输入你的名字：[skinyi@fedora ~]$[skinyi@fedora ~]$ read -p &quot;给你五秒时间输入你的名字：&quot; -t 5 name给你五秒时间输入你的名字：skinyi[skinyi@fedora ~]$ echo $nameskinyi[skinyi@fedora ~]$ read -p &quot;输入你的名字和年龄：&quot; name age ;echo &quot;$name $age&quot;输入你的名字和年龄：skinyi # 未输入的变量默认为空skinyi [skinyi@fedora ~]$ read -p &quot;输入你的名字和年龄：&quot; name age ;echo &quot;$name $age&quot;输入你的名字和年龄：skinyi 18skinyi 18","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Shell","slug":"学习/Shell","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Shell/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://skinyi.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"https://skinyi.github.io/tags/Bash/"},{"name":"脚本编程","slug":"脚本编程","permalink":"https://skinyi.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"}]},{"title":"重学 Shell 编程之基础回顾（一）","slug":"Shell | 重学 Shell 编程之基础回顾（一）","date":"2022-03-29T01:39:48.733Z","updated":"2022-04-22T05:51:31.666Z","comments":true,"path":"2022-03-29-Shell | 重学 Shell 编程之基础回顾（一）.html","link":"","permalink":"https://skinyi.github.io/2022-03-29-Shell%20|%20%E9%87%8D%E5%AD%A6%20Shell%20%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89.html","excerpt":"","text":"Shebang Shebang 是指出现在 Shell 脚本文件第一行中的前两个字符 #!，用以指定命令解释器，例如： #!/bin/sh 会使用 /bin/sh，即 bash(sh 是 bash 的一个软连接)解释器执行脚本内容； #!/usr/bin/python 会使用 python 解释器去执行脚本内容； #!/usr/bin/env NAME，是一种在不同平台上都能找到 NAME 解释器，并用 NAME 解释器执行脚本内容的写法。 🟢 一些细节： 如果脚本没有指定 shebang，脚本执行的时候，默认用当前 shell 去解释脚本，即 $SHELL 环境变量； 如果 shebang 指定了可执行的解释器，如 /bin/bash、/usr/bin/python，那么脚本在执行时，文件名会作为参数传递给解释器； 如果 shebang 指定的解释器没有可执行权限，则会报错：&quot;bad interpreter: Permission denied&quot;； 如果 shebang 指定的解释器不是一个可执行文件，那么则会忽略此指定的解释器，继而转交给当前的 shell 去执行这个脚本； 如果 shebang 指定的解释器不存在，那么会报错 &quot;bad interpreter: No such file or directory&quot;； shebang 指定解释器需写其绝对路径（如：#!/bin/bash），找寻解释器的过程不会在 $PATH 环境变量中找； 如果使用 bash script.sh 这样的命令来执行脚本，脚本中 shebang 所指定的解释器会被忽略而使用命令显式指定的 bash。 执行脚本 执行一个脚本一般有以下几种方法，以执行 script.sh 脚本为例： bash script.sh 或 sh script.sh，被执行的脚本文件可以没有可执行权限，或者脚本没有指定 shebang 时可使用； 使用 绝对/相对 路径执行脚本，被执行的脚本文件需要有可执行权限； source script.sh 或者 . script.sh，在当前 Shell 进程中执行脚本（不产生子 Shell 进程）； 少见用法：sh &lt; script.sh。 一些常见的其他 shell 解释器： /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/tcsh /bin/csh /bin/dash 当前系统支持的解释器类型可以执行 cat /etc/shells 命令查看。不过最受欢迎的解释器还是 bash 解释器。bash 解释器支持以下特性： 文件路径 tab 键补全 命令补全 快捷键 ctrl + a、e、u、k、l 通配符 历史命令 命令别名 命令行展开 Shell 变量 Shell 语言是弱类型语言，如其他编程语言，其也有变量的概念。 定义变量 123\\$ NAME=&quot;VALUE&quot; # 默认所有变量类型都是字符串类型，不能指定类型\\$ echo $&#123;NAME&#125;\\$ VALUE 关于单引号、双引号、反引号用法的一个案例： 123456789\\$ date=&quot;2020-03-29 20:24:56 CST&quot; \\$ VAR=&#x27;$&#123;date&#125;&#x27;;echo $&#123;VAR&#125;\\$ $date # 单引号括起来的字符串不解析变量及命令结果\\$ VAR=&quot;$&#123;date&#125;&quot;;echo $&#123;VAR&#125;\\$ 2020-03-29 20:24:56 CST # 双引号括起来的字符串会解析变量和命令结果\\$ VAR=`date`;echo $&#123;VAR&#125;\\$ 2022年 03月 30日 星期三 08:58:33 CST # 反引号代表执行命令，并取得命令的结果\\$ VAR=&quot;`date`&quot;;echo $&#123;VAR&#125;\\$ 2022年 03月 30日 星期三 09:01:14 CST # 双引号也会解析反引号执行的结果 变量替换及引用 12345\\$ NAME=&quot;ANOTHER_VALUE&quot;\\$ echo $&#123;NAME&#125;\\$ ANOTHER_VALUE\\$ echo $NAME # 省略花括号\\$ ANOTHER_VALUE 变量名命名规范 见名知意，避免使用保留关键字 变量名组成可以是字母、数字以及下划线 不能以数字开头 不能使用标点符号 变量名严格区分大小写 变量的作用域 局部变量：只能在函数内部使用的变量 全局变量：只能在当前 Shell 进程中使用的变量 环境变量：可以在子 Shell 进程中使用的变量 🔵 注意点： 不同于其他编程语言，Shell 函数内部定义的变量的作用域是全局的，即执行这个脚本的进程内可见（不等同于脚本内部可见，因为使用 source 可以在一个 Shell 进程内执行多个脚本），要实现仅在函数内部可见需使用 local 关键字，如：local var=&quot;something&quot; 全局变量只在当前 Shell 进程可见，对其他进程、子进程都不可见，当使用 export 命令将变量进行导出后，父 Shell 进程的被导出的变量将会对子进程可见，该变量即被称作环境变量 父 Shell 进程退出后，此环境变量会消失，如要定义一些常用的环境变量并在启动每个 Shell 进程时自动定义它们，此时就需将它们写在特定的配置文件里 一些特殊变量 变量 描述 $0 当前脚本的文件名 $n(n&gt;=1) 传递给脚本或函数的参数。（n 代表是第几个传递的参数，数字） $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数，被引号括起来时所有参数视作一个整体。 $@ 传递给脚本或函数的所有参数，被引号括起来时每个参数视作一个整体，可遍历每个参数。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是脚本所在的进程 ID。 $! 上一次后台进程的 PID。 $_ 获取上次执行命令的最后一个参数。 123456789101112131415161718192021[skinyi@fedora ~]$ cat test.sh#!/bin/shecho &#x27;使用&quot;$*&quot;打印参数：&#x27;for var in &quot;$*&quot;do echo &quot;$var&quot;doneecho &#x27;使用&quot;$@&quot;打印参数：&#x27;for var in &quot;$@&quot;do echo &quot;$var&quot;done[skinyi@fedora ~]$ bash test.sh a b c d使用&quot;$*&quot;打印参数：a b c d使用&quot;$@&quot;打印参数：abcd 🟢 一般来说，程序、命令的返回值为 0 时代表命令成功执行完成，返回其他值即代表发生了错误，可以根据返回值去查询相应的文档进行排错调试。对于 Shell 来说，函数的返回值跟 C、JAVA 之类的函数返回值的意义和作用是不同的。 查看环境变量 set declare env export 案例：判断传入参数个数。 123456789[skinyi@fedora ~]$ cat test.sh#!/bin/sh[ &quot;$#&quot; -ne &quot;2&quot; ] &amp;&amp; &#123; echo &quot;Expect 2 args!&quot; exit 112&#125;[skinyi@fedora ~]$ bash test.sh 1Expect 2 args! Bash 内建命令 可以使用 compgen -b 查看所有 shell 内建命令。shell 内建命令附加在 bash 命令中，因此它们是随 bash 进程常驻内存的，内建命令执行一般不需要创建子进程。 命令 作用 echo 将指定字符串输出到 STDOUT eval 将指定的参数拼接成一个命令，然后执行该命令 exec 用指定命令替换 shell 进程 export 设置子 shell 进程可用的变量 read 从 STDIN 读取一行数据并将其赋给一个变量 shift 将位置参数依次向下降一个位置 alias 为指定命令定义一个别名 getopts 分析指定的位置参数 let 计算一个数学表达式中的每个参数 local 在函数中创建一个局部变量 readonly 从 STDIN 读取一行数据并将其赋给一个不可修改的变量 readarray 从 STDIN 读取数据行并将其放入索引数组 test 基于指定条件返回退出状态码 0 或 1 trap 如果收到了指定的系统信号，执行指定的命令 wait 等待指定的进程完成，并返回退出状态码 echo 12345678# 常用选项-n 不换行输出-e 解析字符串中的格式化字符，等同于 `printf` 命令的效果# 格式化字符\\n 换行\\r 回车\\t 制表符\\b 退格 eval 12345# 例子[skinyi@fedora ~]$ set 11 22 33 44 # 通过 set 命令设置 $1, $2, $3, $4[skinyi@fedora ~]$ echo $4 # 输出 $4 的值，即 44[skinyi@fedora ~]$ echo &#x27;$&#x27;$# # 此时会输出 $4 而非 $4 的值[skinyi@fedora ~]$ eval echo &#x27;$&#x27;$# # 此时会输出 $4 的值 44 原理：eval 会把参数进行扫描拼接再执行，即上述例子最后一条命令会先扫描得到 echo $4，然后再去执行。 exec exec 会在当前进程中直接执行后面的命令而不会创建子进程，因此当执行的命令退出后该进程也会被销毁，即效果是原本的 bash 进程“不见了”。 1234[skinyi@fedora ~]$ sudo su -[root@fedora ~]\\# exec whoamiroot[skinyi@fedora ~]$ Shell 子串 字串 描述 ${var} 返回变量 var 的值 ${@var} 返回变量 var 的值的字符串长度，注意@替换为# ${var:start} 返回变量 var 的 start 个字符之后的所有字符 ${var:start:length} 返回变量 var 的 start 个字符之后长度为 length 的子字符串 ${var#word} 返回变量 var ”掐头“（最短匹配）后的子字符串 ${var##word} 返回变量 var ”掐头“（最长匹配）后的子字符串 ${var%word} 返回变量 var ”去尾“（最短匹配）后的子字符串 ${var%%word} 返回变量 var ”去尾“（最长匹配）后的子字符串 ${var/pattern/string} 返回变量 var 经单次匹配 pattern 并使用 string 替换后的值 ${var//pattern/string} 返回变量 var 经多次匹配 pattern 并使用 string 替换后的值 ${var:-word} 未定义变量 var 或值为空时返回 word，否则直接返回 var 的值 ${var:=word} 未定义变量 var 或值为空时返回 word，同时将 word 赋值给 var ${var:+word} 当变量 var 已赋值时才返回 word 进行替换，否则不替换 ${var:?MASSAGE} 当变量 var 已赋值时才返回 var 的值，否则输出 MASSAGE 到 STDERR 子串处理示例： 12345678910111213141516171819[skinyi@fedora ~]$ var=&quot;abcdefghi&quot;[skinyi@fedora ~]$ echo $&#123;var&#125;abcdefghi[skinyi@fedora ~]$ echo $&#123;#var&#125;9[skinyi@fedora ~]$ echo $&#123;var:2&#125;cdefghi[skinyi@fedora ~]$ echo $&#123;var:0-5&#125; # 从右数第五个开始输出efghi[skinyi@fedora ~]$ echo $&#123;var:2:4&#125;cdef[skinyi@fedora ~]$ echo $&#123;var:0-4:2&#125; # 从右数第四个开始输出两个字符fg[skinyi@fedora ~]$ echo $&#123;var#a*d&#125;efghi[skinyi@fedora ~]$ echo $&#123;var%e*i&#125;abcd[skinyi@fedora ~]$ echo $&#123;var/cde/edc&#125;abedcfghi 案例——批量文件名修改 12345678910111213141516171819202122# 准备工作：产生实验数据[skinyi@fedora case]$ touch file_&#123;1..5&#125;_draft.&#123;jpg,png&#125; &amp;&amp; lsfile_1_draft.jpg file_2_draft.jpg file_3_draft.jpg file_4_draft.jpg file_5_draft.jpgfile_1_draft.png file_2_draft.png file_3_draft.png file_4_draft.png file_5_draft.png[skinyi@fedora case]$ mv file_2_draft.jpg file_2_finished.jpg[skinyi@fedora case]$ mv file_2_draft.png file_2_delete.png[skinyi@fedora case]$ lsfile_1_draft.jpg file_2_delete.png file_3_draft.jpg file_4_draft.jpg file_5_draft.jpgfile_1_draft.png file_2_finished.jpg file_3_draft.png file_4_draft.png file_5_draft.png[skinyi@fedora case]$# 任务一：将所有结尾为 draft 的 jpg 文件重新命名，去掉结尾的 _draft 后缀[skinyi@fedora case]$ for filename in `ls *draft.jpg`; do mv $filename $&#123;filename/_draft/&#125;; \\done; lsfile_1_draft.png file_2_delete.png file_3_draft.png file_4_draft.png file_5_draft.pngfile_1.jpg file_2_finished.jpg file_3.jpg file_4.jpg file_5.jpg[skinyi@fedora case]$# 任务二：将所有开头为 file 且结尾为 draft 的 png 文件重新命名，修改为 pic_&#123;n&#125;_undo.png 的形式[skinyi@fedora case]$ for filename in `ls *draft.png`; do tmp=$&#123;filename/draft/undo&#125;; \\mv $filename $&#123;tmp/file/pic&#125;; done; lsfile_1.jpg file_2_finished.jpg file_4.jpg pic_1_undo.png pic_4_undo.pngfile_2_delete.png file_3.jpg file_5.jpg pic_3_undo.png pic_5_undo.png[skinyi@fedora case]$ Shell 扩展变量示例： 12345678910111213141516171819202122232425262728293031323334353637383940# 未定义 undefined 变量，定义 defined 变量的值为 defined[skinyi@fedora case]$ echo $undefined[skinyi@fedora case]$ defined=&quot;defined&quot;[skinyi@fedora case]$# var2=$&#123;var1:-word&#125; 用法示例[skinyi@fedora case]$ res=$&#123;undefined:-&quot;not defined&quot;&#125;;printf &quot;$undefined\\n$res\\n&quot;not defined[skinyi@fedora case]$ res=$&#123;defined:-&quot;not defined&quot;&#125;;printf &quot;$defined\\n$res\\n&quot;defineddefined[skinyi@fedora case]$# var2=$&#123;var1:=word&#125; 用法示例[skinyi@fedora case]$ res=$&#123;undefined:=&quot;will defined&quot;&#125;;printf &quot;$undefined\\n$res\\n&quot;will definedwill defined[skinyi@fedora case]$ res=$&#123;defined:=&quot;will redefined?&quot;&#125;;printf &quot;$defined\\n$res\\n&quot;defineddefined[skinyi@fedora case]$ unset undefined # 销毁 undefined 变量[skinyi@fedora case]$ echo $undefined[skinyi@fedora case]$# var2=$&#123;var1:+word&#125; 用法示例[skinyi@fedora case]$ res=$&#123;undefined:+&quot;something&quot;&#125;;printf &quot;$undefined\\n$res\\n&quot;[skinyi@fedora case]$ res=$&#123;defined:+&quot;something&quot;&#125;;printf &quot;$defined\\n$res\\n&quot;definedsomething# var2=$&#123;var1:?MASSAGE&#125; 用法示例[skinyi@fedora case]$ res=$&#123;undefined:?&quot;undefined is not defined!&quot;&#125;;printf &quot;$undefined\\n$res\\n&quot;bash: undefined: undefined is not defined! # 程序立即返回，没有执行后面的语句[skinyi@fedora case]$ res=$&#123;undefined:?&#125; # 也可不指定报错信息，会有默认的 stderr 信息bash: undefined：参数为空或未设置[skinyi@fedora case]$ res=$&#123;defined:?&quot;undefined is not defined!&quot;&#125;;printf &quot;$defined\\n$res\\n&quot;defineddefined[skinyi@fedora case]$ 命令列表、进程列表、进程分组 命令列表，示例：pwd; ls; ... 直接执行，不能放到后台进程 进程列表，示例：(pwd; ls; ...) 在子 shell 中执行然后返回父 shell 进程分组，示例：{pwd; ls; ...} 不会启动子 shell，与命令列表一样，只是给命令进行了分组 🟢 可以通过环境变量 BASH_SUBSHELL 来判断自己是否是子 Shell，若该变量的值为 0，则代表自己不是 subshell，若为其他值则是。 🟢 创建子 shell 时新建子进程但子进程由 bash 维护，只能通过 $BASHPID 获取PID，与父进程共用同一个 POSIX 语义下的 PID 与 PPID。本质上实现了多进程。 12345678910111213141516[skinyi@fedora ~]$ pwd; ls; echo $BASH_SUBSHELL/home/skinyicase gh-pages package-lock.json test.sh0[skinyi@fedora ~]$ (pwd; ls; echo $BASH_SUBSHELL)/home/skinyicase gh-pages package-lock.json test.sh1[skinyi@fedora ~]$ echo $BASH_SUBSHELL;(echo $BASH_SUBSHELL;(echo $BASH_SUBSHELL;(echo $BASH_SUBSHELL;(echo $BASH_SUBSHELL;(echo $BASH_SUBSHELL;)))))012345[skinyi@fedora ~]$","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Shell","slug":"学习/Shell","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Shell/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://skinyi.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"https://skinyi.github.io/tags/Bash/"},{"name":"脚本编程","slug":"脚本编程","permalink":"https://skinyi.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"}]},{"title":"Docker 容器的本质及底层技术","slug":"Docker | Docker 容器的本质及底层技术","date":"2022-03-21T05:27:20.144Z","updated":"2022-03-24T14:51:08.422Z","comments":true,"path":"2022-03-21-Docker | Docker 容器的本质及底层技术.html","link":"","permalink":"https://skinyi.github.io/2022-03-21-Docker%20|%20Docker%20%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF.html","excerpt":"","text":"容器的本质 容器本身是一种进程隔离技术。容器为进程提供了一个隔离的环境，容器内的进程无法访问容器外的进程。以运行一个 ubuntu 容器为例： 12[root@localhost ~]\\# docker run -it ubunturoot@d304e6f37918:\\# top # 执行 top 命令 在主机上查看系统进程： 1234567[root@localhost ~]\\# ps -ef# ......root 3630 3629 0 13:48 pts/0 00:00:00 docker run -it ubunturoot 3648 1 0 13:48 ? 00:00:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id d304e6f3791808ca34c8f8361da22root 3674 3648 0 13:48 pts/0 00:00:00 bashroot 3775 3674 0 13:49 pts/0 00:00:00 top# ...... 其中第一条记录是启动该容器时的命令，其父进程是执行该命令的 bash 进程；第二条记录是该容器的进程，其父进程是 systemd 进程，由 systemd 进程直接执行 containerd-shim-runc-v2 命令启动容器的进程；第三条记录表明该容器的进程自动启动一个 bash 进程用以接受用户的指令；第四条记录表明在该 bash 进程中执行了 top 命令。 进程隔离 以上示例印证了容器的本质是一个进程，容器中的进程是容器进程的子进程或子子进程。但如何表明该容器进程是与其他进程隔离的呢？在上述 Ubuntu 容器中执行 ps -ef 命令： 1234root@baf49ec287bb:\\# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 06:15 pts/0 00:00:00 bashroot 9 1 0 06:15 pts/0 00:00:00 ps -ef 可以看到该容器的 bash 进程的 PID 竟然是 1 而不是和主机一样是 systemd 进程，而在主机上其进程号是 3674，由此可以视作该容器进程里的子进程认为自己运行在一个“与世隔绝”的操作系统世界里。 文件系统隔离 在该容器内部执行： 123456789101112131415161718root@baf49ec287bb:\\# ls -l /devtotal 0crw--w----. 1 root tty 136, 0 Mar 21 06:42 consolelrwxrwxrwx. 1 root root 11 Mar 21 06:15 core -&gt; /proc/kcorelrwxrwxrwx. 1 root root 13 Mar 21 06:15 fd -&gt; /proc/self/fdcrw-rw-rw-. 1 root root 1, 7 Mar 21 06:15 fulldrwxrwxrwt. 2 root root 40 Mar 21 06:15 mqueuecrw-rw-rw-. 1 root root 1, 3 Mar 21 06:15 nulllrwxrwxrwx. 1 root root 8 Mar 21 06:15 ptmx -&gt; pts/ptmxdrwxr-xr-x. 2 root root 0 Mar 21 06:15 ptscrw-rw-rw-. 1 root root 1, 8 Mar 21 06:15 randomdrwxrwxrwt. 2 root root 40 Mar 21 06:15 shmlrwxrwxrwx. 1 root root 15 Mar 21 06:15 stderr -&gt; /proc/self/fd/2lrwxrwxrwx. 1 root root 15 Mar 21 06:15 stdin -&gt; /proc/self/fd/0lrwxrwxrwx. 1 root root 15 Mar 21 06:15 stdout -&gt; /proc/self/fd/1crw-rw-rw-. 1 root root 5, 0 Mar 21 06:15 ttycrw-rw-rw-. 1 root root 1, 9 Mar 21 06:15 urandomcrw-rw-rw-. 1 root root 1, 5 Mar 21 06:15 zero 可以发现该容器的设备文件中没有主机中的硬盘 block 文件，这是由于该容器的文件系统也是和主机不一样的独立文件系统。那么容器的文件系统在哪儿呢？使用 docker inspect 容器名|容器ID 命令并查看输出的 GraphDriver 字段来找到容器的文件系统文件在主机中的位置。 123456789[skinyi@localhost ~]\\$ sudo docker inspect -f &#x27;&#123;&#123;json .GraphDriver&#125;&#125;&#x27; ubuntu | jq&#123; &quot;Data&quot;: &#123; &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/7472d22959e652e97acb49e6de5dd704bd2fb46de0f35d12a7b0cfbba1655cb5/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/7472d22959e652e97acb49e6de5dd704bd2fb46de0f35d12a7b0cfbba1655cb5/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/7472d22959e652e97acb49e6de5dd704bd2fb46de0f35d12a7b0cfbba1655cb5/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot;&#125; 该容器的文件系统位置就在主机上 UpperDir 属性所指向的位置。主机另起终端在该目录下找到容器的 dev 目录，并 ls -l 会发现该目录是空的，其实这是正常的，因为容器中该目录是内存数据中的一部分而未持久化到主机硬盘中。 文件隔离的本质技术是使用 chroot 系统调用，该系统调用用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，并让这些进程只能访问到该目录，此功能的初衷是为每个进程提供独立的磁盘空间。 我们可以模拟创建容器所进行的操作： 123456[root@localhost ~]\\# cd /var/lib/docker/overlay2/7472d22959e652e97acb49e6de5dd704bd2fb46de0f35d12a7b0cfbba1655cb5/[root@localhost 7472d22959e652e97acb49e6de5dd704bd2fb46de0f35d12a7b0cfbba1655cb5]\\# chroot diffroot@localhost:\\# ls bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr varroot@localhost:\\# pwd/ 此时无法执行 ps -ef 命令，因为其内存文件系统还没有挂载。但我们的实验可以到此为止。 Linux 命名空间技术 后面的容器技术的实现基本上都离不开 Linux 的 Namespace 技术，该技术是 Linux 提供的内核级环境隔离的方法，它提供了以下的系统隔离能力： Mount Namespace 提供磁盘挂载点和文件系统的隔离能力 IPC Namespace 提供进程间通信隔离的能力 Network Namespace 提供网络隔离能力 UTS Namespace 提供主机名及主机域的隔离能力 PID Namespace 提供进程隔离能力 User Namespace 提供用户隔离能力 在主机上查看容器的 bash 进程、主机的 bash 进程以及主机 systemd 进程的命名空间： 123456789101112131415161718192021222324252627282930313233343536[root@localhost ~]\\# ls -l /proc/3674/ns总用量 0lrwxrwxrwx. 1 root root 0 3月 21 15:42 cgroup -&gt; &#x27;cgroup:[4026532847]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 ipc -&gt; &#x27;ipc:[4026532777]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 mnt -&gt; &#x27;mnt:[4026532775]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:41 net -&gt; &#x27;net:[4026532780]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 pid -&gt; &#x27;pid:[4026532778]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 pid_for_children -&gt; &#x27;pid:[4026532778]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 time -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 time_for_children -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 uts -&gt; &#x27;uts:[4026532776]&#x27;[root@localhost ~]\\# ls -l /proc/self/ns总用量 0lrwxrwxrwx. 1 root root 0 3月 21 15:42 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 ipc -&gt; &#x27;ipc:[4026531839]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 mnt -&gt; &#x27;mnt:[4026531840]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 net -&gt; &#x27;net:[4026532000]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 pid -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 pid_for_children -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 time -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 time_for_children -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:42 uts -&gt; &#x27;uts:[4026531838]&#x27;[root@localhost ~]\\# ls -l /proc/1/ns总用量 0lrwxrwxrwx. 1 root root 0 3月 21 13:05 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 ipc -&gt; &#x27;ipc:[4026531839]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 mnt -&gt; &#x27;mnt:[4026531840]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 net -&gt; &#x27;net:[4026532000]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 pid -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:50 pid_for_children -&gt; &#x27;pid:[4026531836]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 time -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 15:50 time_for_children -&gt; &#x27;time:[4026531834]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 user -&gt; &#x27;user:[4026531837]&#x27;lrwxrwxrwx. 1 root root 0 3月 21 13:42 uts -&gt; &#x27;uts:[4026531838]&#x27; 可以发现主机的 bash 进程和 systemd 进程完全一致，但容器中的进程和主机进程中的存在部分差别。命名空间中还包含 cgroup 命名空间，这涉及到 Linux 管理硬件资源分配的一种技术。 CGroup 控制组 CGroup 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的计算资源（CPU、内存、I/O 等）的机制。CGroup 提供了以下功能： 限制进程组可以使用的资源数量 进程组的优先级控制 记录进程组使用的资源数量 进程组隔离 进程组控制 容器技术使用 CGroup 技术限制容器对主机资源的使用。 Containerd 容器运行时 Containerd 是一个强大的工业级容器运行时环境，其脱胎于 docker 的 libcontainerd 后经开源独立以及不断完善从 RunC 发展到现在的 Containerd（谷歌及其他大厂的一系列操作下）。现在谷歌的 K8S 默认集成的容器运行时环境已经是 Containerd，而不是原本的 Docker，Docker 现在更多代表的其实是操纵 Containerd 的一个客户端。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"云计算与阿里云 ACP 概述","slug":"云计算 | 云计算与阿里云 ACP 概述","date":"2022-03-13T02:02:31.486Z","updated":"2022-03-14T13:17:58.484Z","comments":true,"path":"2022-03-13-云计算 | 云计算与阿里云 ACP 概述.html","link":"","permalink":"https://skinyi.github.io/2022-03-13-%E4%BA%91%E8%AE%A1%E7%AE%97%20|%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91%20ACP%20%E6%A6%82%E8%BF%B0.html","excerpt":"","text":"云计算与虚拟化概述 云计算 云计算是一种模型，它可以实现随时随地、便捷地、随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。 云计算五大特征： On-Demand Self-Service 按需自助服务 Rapid Elasticity 快速弹性伸缩 Resource Pooling 资源化池 Measured Service 可计量服务 Broad Network Access 广泛网络接入 云计算的四大部署模式： Private Cloud: 私有云 Public Cloud: 公有云（阿里云 ECS） Community Cloud: 社区云（医药行业云、运输行业云、金融行业云） Hybrid Cloud: 混合云（采用两种或两种以上上述部署模式部署） 云计算的核心技术是虚拟化技术，虚拟化其实主要提供了 Iaas 模式的服务，云计算的其他服务模式都是在 IaaS 的基础上发展而来的。 云计算的三种服务模式： IaaS(Infrastructure as a Service) 基础设施即服务: 出租处理能力、存储空间、网络带宽等基本计算资源，如：亚马逊 EC2、弹性云服务器 PaaS(Platform as a Service) 平台即服务：为客户开发的应用程序提供可部署的云服务，如：Microsoft Azure、数据库服务 SaaS(Software as a Service) 软件即服务：在网络上提供可直接使用的应用程序，如：Office 365、各种云 APP 云计算的八个通用特点：大规模、弹性计算、标准化、地理分布、虚拟化、面向服务、低成本、高安全性。 云计算的发展历程： 云计算 1.0 计算虚拟化 云计算 2.0 软件定义与整合 云计算 3.0 云原生与重构业务 虚拟化 虚拟化是指一种将硬件转变（抽象）为软件的技术。虚拟化是资源的逻辑表示，其不受物理限制的约束。虚拟化创建了一层隔离层，把硬件和上层应用分离开来，允许在一个硬件资源上运行多个逻辑应用。 常见的虚拟化：服务器虚拟化、网络虚拟化、存储虚拟化、桌面虚拟化等。其中服务器虚拟化的结构自下而上分别是：宿主机、宿主机操作系统、Hypervisor、客户机、客户机操作系统。 Hypervisor：虚拟机技术的核心、虚拟化层的具体实现。 创造并运行虚拟机的软件、固件或者硬件； 以软件的方式，实现一套和物理主机环境完全一样的虚拟环境，物理主机有的所有资源，包括 CPU、内存、网络 IO、设备 IO 等都有； 相当于物理主机的资源进行划分和隔离，供上层使用（共享硬件）。 主流 Hypervisor 产品：VMware ESXi、Microsoft Hyper-V、Linux KVM、Red Hat Enterprise Virtualization(RHEV)、Citrix XenServer、Oracle VM、VMware Workstation、VMware Player、VMware Fusion. 根据在整个系统中的位置不同，虚拟化架构分为以下几种： 寄居虚拟化架构：寄居虚拟化架构指在宿主操作系统之上安装和运行虚拟化程序，依赖于宿主操作系统对设备的支持和物理资源的管理。（VMware） 裸金属虚拟化架构：裸金属虚拟化架构指直接在硬件上面安装虚拟化软件，再在其上安装操作系统和应用，依赖虚拟层内核和服务器控制台进行管理。（阿里云弹性裸金属服务器，ECS Bare Metal Instance） 操作系统虚拟化架构：操作系统虚拟化架构在操作系统层面增加虚拟服务器功能。操作系统虚拟化架构把单个的操作系统划分为多个容器，使用容器管理器来进行管理。宿主操作系统负责在多个虚拟服务器（即容器）之间分配硬件资源，并且让这些服务器彼此独立。（docker） 混合虚拟化架构将一个内核级驱动器插入到宿主操作系统内核。这个驱动器作为虚拟硬件管理器来协调虚拟机和宿主操作系统之间的硬件访问。（KVM） 服务器虚拟化技术的分类： 按照虚拟对象来分可分为：CPU 虚拟化、内存虚拟化、I/O 虚拟化； 按照虚拟化程度分：全虚拟化、半虚拟化、硬件辅助虚拟化。 虚拟化的特点： 分区：在单一物理服务器上同时运行多个虚拟机 隔离：在单一物理服务器上的多个虚拟机之间相互隔离 封装：整个虚拟机执行环境封装在独立文件中，可以通过移动文件的方式来迁移该虚拟机 相对于硬件隔离：虚拟机无需修改，即可在任何服务器上运行 CPU 虚拟化 CPU 虚拟化分为 CPU 全虚拟化技术、CPU 半虚拟化技术以及 CPU 硬件辅助虚拟化技术。CPU的虚拟化技术可以单CPU模拟多CPU并行，允许一个平台同时运行多个操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 CPU 全虚拟化 CPU 全虚拟化主要采用优先级压缩技术（Ring Compression）和 二进制代码翻译技术（Binary Translation）。优先级压缩技术让 VMM 和 Guest 运行在不同的特权级下。 对 X86 架构而言，即 VMM 运行在最高特权级别 Ring 0 下，Guest OS 运行在Ring 1 下，用户应用运行在 Ring 3 下。因此 Guest OS 的核心指令无法直接下达 到计算机系统硬件执行，而是需要经过 VMM 的捕获和模拟执行（部分难以虚拟化的指令需要通过 Binary Translation技术进行转换）。 CPU 半虚拟化 CPU 半虚拟化主要采用 Hypercall 技术。Guest OS 的部分代码被改变，从而使 Guest OS 会将和特权指令相关的操作都转换为发给 VMM 的 Hypercall（超级调用），由 VMM 继续进行处理。而Hypercall 支持的批处理和异步这两种优化方式，使得通过 Hypercall 能得到近似于物理机的速度。 CPU 硬件辅助虚拟化 CPU 硬件辅助虚拟化目前主要有 Intel 的 VT-x 和 AMD 的 AMD-V 这两种技术。其核心思想都是通过引入新的指令和运行模式，使 VMM 和 Guest OS 分别运行在不同模式（ROOT 模式和非 ROOT 模式）下，且 Guest OS 运行在 Ring 0 下。通常情况下，Guest OS 的核心指令可以直接下达到计算机系统硬件执行，而不需要经过 VMM。当 Guest OS 执行到特殊指令的时候，系统会切换到 VMM，让 VMM 来处理特殊指令。 内存虚拟化 内存虚拟化的产生源于 VMM 与客户系统在对物理内存的认识上存在冲突，造成物理内存真正拥有者—— VMM 必须对系统访问的内存进行一定程度上的虚拟化。 内存全虚拟化技术 通过使用影子页表（Shadow Page Table）实现虚拟化。 VMM 为每个Guest 都维护一个影子页表，影子页表维护虚拟地址（VA）到机器地址（MA）的映射关系。而 Guest 页表维护 VA 到客户机物理地址（GPA）的映射关系。 当 VMM 捕获到 Guest 页表的修改后，VMM 会查找负责 GPA 到 MA 映射的 P2M 页表或者哈希函数，找到与该 GPA 对应的 MA，再将 MA 填充到真正在硬件上起作用的影子页表，从而形成 VA 到 MA 的映射关系。而 Guest 的页表则无需变动。 内存半虚拟化技术 通过使用页表写入法实现虚拟化。 Guest OS 在创建一个新的页表时，会向 VMM 注册该页表。之后在 Guest 运行的时候，VMM 将不断的管理和维护这个表，使 Guest 上面的程序能直接访问到合适的地址。 内存硬件辅助虚拟化技术 通过扩展页表 EPT（extended page table）实现虚拟化。 EPT 通过使用硬件虚拟化技术，使其能在原有的页表的基础上，增加一个 EPT 页表，用于记录 GPA 到 MA 的映射关系。VMM 预先把 EPT 页表设置到 CPU 中。 Guest 修改 Guest 页表，无需 VMM 干预。地址转换时，CPU 自动查找两张页表完成 Guest 虚拟地址到机器地址的转换，从而降低整个内存虚拟化所需的开销。 阿里云及阿里云云计算认证 阿里云 ACP 认证是面向使用阿里云云计算产品的架构、开发、运维人员的专业技术认证，主要涉及阿里云的计算、存储、网络、安全类的核心产品。该认证在 2020 年 1 月 15 日之后在原有通过线下机考的要求之上新增了完成前置实验的要求，其线下机考题分单选（70 道）和多选（30 道）两种题型，每题 1 分，总分 100 分，考生需达到 80 分以上才算通过。 具体要求可参见官方考试大纲。 阿里云云计算相关概念 ECS 云服务器 ECS(Elastic Compute Service) 是一种简单高效、处理能力可弹性伸缩的计算服务。帮助您构建更稳定、安全的应用，提升运维效率，降低IT成本，使您更专注于核心业务创新。 SLB 负载均衡 负载均衡SLB（Server Load Balancer）是一种对流量进行按需分发的服务，通过将流量分发到不同的后端服务器来扩展应用系统的吞吐能力，并且可以消除系统中的单点故障，提升应用系统的可用性。阿里云负载均衡SLB分为两类：传统型负载均衡CLB和应用型负载均衡ALB。 Auto Scaling 弹性伸缩 弹性伸缩（Auto Scaling）是根据业务需求和策略自动调整计算能力（即实例数量）的服务。您可以指定实例的类型，即ECS实例或ECI实例。在业务需求增长时，弹性伸缩自动增加指定类型的实例，来保证计算能力；在业务需求下降时，弹性伸缩自动减少指定类型的实例，来节约成本。弹性伸缩不仅适合业务量不断波动的应用程序，同时也适合业务量稳定的应用程序。 OSS 对象存储 阿里云对象存储OSS（Object Storage Service）是一款海量、安全、低成本、高可靠的云存储服务，可提供99.9999999999%（12个9）的数据持久性，99.995%的数据可用性。多种存储类型供选择，全面优化存储成本。 OSS具有与平台无关的RESTful API接口，您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 您可以使用阿里云提供的API、SDK接口或者OSS迁移工具轻松地将海量数据移入或移出阿里云OSS。数据存储到阿里云OSS以后，您可以选择标准存储（Standard）作为移动应用、大型网站、图片分享或热点音视频的主要存储方式，也可以选择成本更低、存储期限更长的低频访问存储（Infrequent Access）、归档存储（Archive）、冷归档存储（Cold Archive）作为不经常访问数据的存储方式。 CDN 内容分发网络 阿里云内容分发网络CDN（Content Delivery Network）是建立并覆盖在承载网之上，由遍布全球的边缘节点服务器群组成的分布式网络。阿里云CDN能分担源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度。 VPC 专有网络 专有网络是您专有的云上私有网络。您可以完全掌控自己的专有网络，例如选择IP地址范围、配置路由表和网关等，您可以在自己定义的专有网络中使用阿里云资源，如云服务器、云数据库RDS和负载均衡等。 云盾和云监控 云盾和云监控是指阿里推出的针对云产品的安全防御以及监测系统。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"ACP","slug":"学习/ACP","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/ACP/"}],"tags":[{"name":"认证考试","slug":"认证考试","permalink":"https://skinyi.github.io/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"},{"name":"ACP","slug":"ACP","permalink":"https://skinyi.github.io/tags/ACP/"},{"name":"云计算","slug":"云计算","permalink":"https://skinyi.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"阿里云","slug":"阿里云","permalink":"https://skinyi.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"宇宙的尽头是考公之话说 vlookup 函数","slug":"Excel | 宇宙的尽头是考公之话说 vlookup 函数","date":"2022-03-05T12:51:48.680Z","updated":"2022-03-13T02:17:58.370Z","comments":true,"path":"2022-03-05-Excel | 宇宙的尽头是考公之话说 vlookup 函数.html","link":"","permalink":"https://skinyi.github.io/2022-03-05-Excel%20|%20%E5%AE%87%E5%AE%99%E7%9A%84%E5%B0%BD%E5%A4%B4%E6%98%AF%E8%80%83%E5%85%AC%E4%B9%8B%E8%AF%9D%E8%AF%B4%20vlookup%20%E5%87%BD%E6%95%B0.html","excerpt":"","text":"废话 这篇文章构思了很久了，奈何去外地出差加班今天才抽出晚上的时间来写，做私企的社畜确实没有公务员安逸。宁夏公务员招考公告刚发布，今日头条便推送过来了新闻，我也就关注了下。截至 3 月 2 日 10 点，宁夏报名人数达到了 73095 人，社会发展贫富差距拉大以及近年疫情影响下人们追求安稳饭碗的观念愈发深入人心了。生活安稳、工作体面的体制内人员在婚恋市场都有一定的优势，每当我妈手机里的快手直播间操着方言的媒婆说“这家女子想找个体制内的呢”，身在活多钱少的私企的我的寂寞的内心顿时哇凉哇凉的。于是我决定看看今年的报考人数打算打算，不行就争取个以后做我现在公司甲方爸爸的机会，想着我以后刁难我现在同事时的威风，嘴角不禁上扬了起来。 问题的提出 暗中观察到了 3 月 2 日，报名截止的最后一天，10 点出了最后一次的报考人数公示。统计了下最高缴费招考比的职位是 437:1 的民革银川市委员会一级科员，也不知道这个职位有什么吸引人的地方。我也根据我自身的想法，将职位过滤了一遍，最终筛出来的大致自身条件不受限可报的职位有 25 个，接下来就是要决定报哪个了，我想着根据缴费招考比选最低的那个竞争会小一些。要从 25 个职位中一一比对算缴费招考比并进行比较确实有点费劲，如果能计算机辅助的完成这个任务会更好些。 问题分析 我比对了这两张表，发现他们有两个共同的列：职位名称和职位代码。看到职位代码，作为技术人员的我想到了主键和 SQL。如果能在 Excel 中执行 SQL 查询，我上面的问题不难解决而且强大的 Excel 也确实内置了对 SQL 的支持，但其实像我现在的问题根本用不着这么复杂的方法，最好的方法是用 Excel 数据处理的函数大法。 以上问题的解决思路可以被分解为：1. 从表二根据表一筛选出来的职位代码（职位名称也行，但我还是习惯用可以标识唯一性的代码串）查出缴费人数和招考人数并记录在表一；2. 在表一计算缴费和招考人数的比例；3. 表一根据此比例进行排序；4. 从表一根据排序结果综合自身其他意愿选择报考职位。 以上解决方法中最难的其实是第一步，其他方法中涉及的计算和排序都十分简单。很多人都不太会用到 Excel 提供的一个强大的查找函数 vlookup 可以满足步骤一的需要。以下是这个函数的介绍： VLOOKUP(lookup_value,table_array,col_index_num,[range_lookup]) 按行查找表格或区域内容 其中各参数的意义是： lookup_value：要查找的值，也被称为查阅值（该参数既可以是单元格也可以是定值）。 table_array：查阅值所在的区域。 需注意：查阅值应该始终位于所在区域的第一列，这样 VLOOKUP 才能正常工作。 例如，如果查阅值位于单元格 C2 内，那么你的区域应该以 C 开头。 col_index_num：区域中包含返回值的列号。 例如，如果指定 B2：D11 作为区域，则应该将 B 计为第一列，将 C 作为第二列，以此类比。 range_lookup：（可选）如果需要返回值的近似匹配，可以指定 TRUE；如果需要返回值的精确匹配，则指定 FALSE。 如果没有指定任何内容，默认值将始终为 TRUE 或近似匹配。 解决步骤 了解这个函数之后就很简单了，为了方便，在表一所在的工作簿新建工作表，将表二的内容复制过去，如图： 在职位表新建列：缴费人数、缴费招考比。职位表的结构就变成了： ◢ A B C D E F G H I J K L M N O P 1 序号 招考单位 部门及职位 职位简介 职位代码 招考人数 专业要求 学历要求 学位要求 政治面貌 其他条件 备注 申论试卷类型 联系电话 缴费人数 缴费招考比 308 304 石嘴山市 石嘴山市市直部门一级科员（一） 负责综合管理服务、信息化建设、工程建设项目规划、项目审批等工作 017001 2 计算机类、电子信息类、建筑类、水利类 本科及以上 学士及以上 不限 限男性 合并职位：市人力资源和社会保障局1人、民政局1人、团市委（参照公务员法管理群团机关）1人、就业创业服务局（参照公务员法管理事业单位）1人 A卷 0952-2012332 0952-2218747 140 70 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 然后就可以用 vlookup 函数自动从统计表根据职位代码查找到对应职位的缴费人数。简单起见，可以用 Excel 的函数向导手动可视化的选择或确定出函数的参数，从菜单栏选中：公式-插入函数，在搜索函数对话框里输入 vlookup 并点击转到，然后确保从选择函数中选中 vlookup 后点击确定。 点击每项参数后面红圈里的按钮就可以在工作表中选择参数或参数范围： 最终完整函数形式是：=VLOOKUP(E308,统计表!D2:I765,6,0)，意思是从统计表的 D2 到 I765 的单元格范围内对比 D 列的值是否为 E308 里的值，若精确匹配则返回该单元格所选范围的第六行的值为该函数的结果。 观察之后发现对应正确，然后就可以用 Excel 强大的填充工具将其他职位的缴费人数也根据第一个筛选出来的岗位填充进去。在我的操作中，填充后的函数虽然有问题但工作良好，因为职位表和统计表的职位表的排序是对应的，此时若在未对应的情况下就会出现问题，有的单元格可能会出现 #N/A 值。 问题思考 造成上述问题的原因是我们未锁定 table_array 参数的所选范围的行值，每次往下下拉填充统计范围的行值都会自增，如我在下面随便选中的一个填充后的单元格的公式变成了：=VLOOKUP(E615,统计表!D486:I1249,6,0)，这在无序情况下会出错。 为了使该参数固定，可以借助 $ 符号进行限定，这样每次填充时该函数的第二个参数就是不变的了。 于是，筛选后的职位表的第一行的公式可以写成：=VLOOKUP(E308,统计表!D$2:I$765,6,0)，然后再往下填充。再选中刚才填充的公式，其变成了：=VLOOKUP(E615,统计表!D$2:I$765,6,0)，这样就比较精准了。 计算缴费招考比，以筛选后的职位表的第一行为例：=O308/F308。然后用排序工具排序就完成任务了。 还是废话 看了最后的结果，不仅感叹现在的公务员考试越来越卷，我估计我也将只会是陪考员中的一员。由此看来还是再钻研钻研 Excel 的 SQL 查询功能比较现实。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Office","slug":"学习/Office","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Office/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://skinyi.github.io/tags/Excel/"},{"name":"Office","slug":"Office","permalink":"https://skinyi.github.io/tags/Office/"},{"name":"避免加班","slug":"避免加班","permalink":"https://skinyi.github.io/tags/%E9%81%BF%E5%85%8D%E5%8A%A0%E7%8F%AD/"},{"name":"少加班","slug":"少加班","permalink":"https://skinyi.github.io/tags/%E5%B0%91%E5%8A%A0%E7%8F%AD/"}]},{"title":"Docker Run 命令详解","slug":"Docker | Docker Run 命令详解","date":"2022-03-01T12:31:09.667Z","updated":"2022-03-28T06:09:02.646Z","comments":true,"path":"2022-03-01-Docker | Docker Run 命令详解.html","link":"","permalink":"https://skinyi.github.io/2022-03-01-Docker%20|%20Docker%20Run%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","excerpt":"","text":"Docker 在隔离的容器中运行进程。容器是在主机上运行的进程。主机可以是本地或远程的。当执行 docker run 时，运行的容器进程是独立的，因为它有自己的文件系统、自己的网络和自己的独立于主机的进程树。 以下介绍了如何在运行时使用 docker run 命令定义容器的资源。 docker run 命令的一般形式 基本的 docker run 命令采用以下形式： 1\\$ docker run [选项] IMAGE[:标签|@摘要] [命令] [参数...] docker run 命令必须指定从中生成容器的镜像。镜像开发人员可以定义与以下内容相关的镜像默认值： 分离或前台运行； 容器标识； 网络设置； 对CPU和内存的运行时约束。 通过 docker run [选项] 用户可以添加或覆盖开发人员设置的镜像默认值。此外，用户可以覆盖几乎所有由 Docker 运行时本身设置的默认值。也正因为如此，docker run 比任何其他 Docker 命令都有更多选项。 🟢 根据你的 Docker 系统配置，你可能需要在 docker run 命令前面加上 sudo 以确保命令正常执行生效。为了避免在 docker 命令中使用 sudo，你的系统管理员可以创建一个名为 docker 的 Unix 组并向其中添加 docker 操作用户。 仅用户可指定的选项 仅执行 docker run 命令的用户可指定以下命令执行时的选项： 独立进程或前台执行 独立进程（-d 选项） 前台执行 容器标识 名称（--name 选项） PID 值 IPC 设置（--ipc） 网络设置 重启策略（--restart） 清理（--rm） 运行时资源约束 运行时特权及 Linux capabilities 独立进程或前台执行 当启动了一个 Docker 容器，你必须先决定你是否想在后台以“分离”的模式或者默认在前台运行容器，可以使用 -d[=&lt;true|false&gt;] 选项来指定分离式模式，容器会在后台运行并打印出该容器的 id。 根据设计，当用于运行容器的根进程退出时，以分离模式启动的容器也会退出，除非你还指定了 -rm 选项。如果将 -d 与 -rm 一起使用，当容器退出或守护程序退出时(无论哪个先退出)，容器将被删除。 不要向分离模式运行的容器传递 service xxx start 的命令。如以下命令尝试创建容器后启动 nginx 服务。 1\\$ docker run -d -p 80:80 my_image service nginx start 即使这也会成功的启动容器内部的 nginx 服务，但是它不符合分离的容器范例，因为随着根进程（service nginx start）的退出，分离式容器也会跟着停止，从而导致 nginx 服务启动了却不能用。要启动一个进程如 nginx web 服务器应该按照下述方法： 1\\$ docker run -d -p 80:80 my_image nginx -g &#x27;daemon off;&#x27; 要使用分离的容器进行输入/输出则必须使用网络连接或共享卷，因为该容器不会监听运行 docker run 的命令行。 为了将分离出去的容器转至前台运行，可以使用 docker attach 命令。将运行于前台的容器切至后台运行可以使用 Ctrl + p + q 快捷键。 前台运行 在前台模式下（默认模式当未指定 -d 选项），docker run 可以启动容器中的进程并且将当前终端附加到该进程的标准输入、输出以及标准错误流中。它甚至可以“假装”成为一个 TTY 会话（如大多数命令行可执行文件期望的那样）并且传递信号。以下这些选项都是可配置的： -a=[] ：附加到标准输入、标准输出和 / 或标准错误流 -t ：分配一个伪 TTY --sig-proxy=true：将所有收到的信号代理到进程(仅限非TTY模式) -i ：即使没有连接，也保持标准输入流打开 如果你没有指定 -a 选项，Docker 就会将进程的标准输入、错误流附加到当前终端中，你也可以通过 -a 选项指定哪个流进行附加，比如： 1\\$ docker run -a stdin -a stdout -i -t ubuntu /bin/bash 对于交互式进程（如命令行 shell），必须一起指定 -i 和 -t 选项来为容器进程分配一个 TTY，这两个选项常被简写为 -it。当客户端从管道中接收标准输入流时指定 -t 选项通常是被禁止的，比如： 1\\$ echo test | docker run -i busybox cat 🔴 注意：在容器中运行的 PID 为 1 的进程会被 Linux 特殊看待：它会忽略任何信号的默认行为。最终就会导致收到 SIGINT 和 SIGTERM 信号的进程不会终止除非它被编码进行指定。 容器标识 容器名称（--name） 用户可以通过三种方式来标识容器： 标识符类型 例子 UUID 长标识符 “f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778” UUID 短标识符 “f78375b1c487” 名称 “evil_ptolemy” 其中，UUID 标识符由 Docker 守护程序生成。如果未通过 --name 选项来给容器赋予名称，则守护程序会生成一串随机字符来自动命名该容器。给容器进行有意义的命名是一个比较好的习惯。如果你制定了容器的名称，就可以在 Docker 网络中引用容器时使用它，不论是前台还是后台运行的容器。 默认网桥网络上的容器必须被链接以通过名称进行通信。 最后，为了便于自动化，你可以让 Docker 将容器的 ID 写入到你选择的文件中。这类似于一些程序会将自身进程 ID 写入到文件中去，正如你见过的 PID 文件。 1--cidfile=&quot;&quot;：将容器 ID 写入文件 镜像[:标签] 虽然严格来说这不是一种标识容器的方法，但是你可以通过将 image[:tag] 添加到命令中来指定您想要运行容器的镜像版本。比如：docker run ubuntu:14.04。 镜像[@摘要] 使用 v2 或更高版本镜像格式的镜像有一个称为摘要的内容可寻址标识符。只要用于生成镜像的输入不变，摘要值就是可预测和可参考的。 以下示例使用在运行 alpine 镜像时使用了 sha256:9cacb71397b640ECA97488cf08582AE4068513101088e9f96c9814bfda95e0 摘要： 1\\$ docker run alpine@sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0 date PID 设置（--pid） --pid=&quot;&quot; ：为容器设置 PID（进程） 命名空间模式。可选值：container:&lt;name|id&gt;：加入其他容器的 PID 命名空间；host：使用容器中的主机的 PID 命名空间。 默认情况下，所有容器都启用了 PID 命名空间。 PID 命名空间提供了进程的分离。PID 命名空间删除了系统进程的视图，并允许重用进程 ID，包括 pid 1。 在某些情况下，你希望你的容器共享主机的进程名称空间，基本上允许容器内的进程看到系统上的所有进程。例如，您可以使用像 strace 或 gdb 这样的调试工具构建一个容器，但是在调试容器中的进程时，你希望使用这些工具。 例子：在容器中执行 `htop` 创建 Dockerfile: 123FROM alpine:latestRUN apk add --update htop &amp;&amp; rm -rf /var/cache/apk/*CMD [&quot;htop&quot;] 构建此 Dockerfile 并将镜像标记为 myhtop： 1\\$ docker build -t myhtop . 使用以下命令在容器中运行 htop 命令： 1\\$ docker run -it --rm --pid=host myhtop 加入其他可以被用来调试该容器的 pid 命名空间。 例子 开启一个运行 redis 服务的容器： 1\\$ docker run --name myredis -d redis 通过运行含有 strace 的其他容器来调试 redis 容器： 12\\$ docker run -it --pid=container:my-redis my_strace_docker_image bash\\$ strace -p 1 UTS 设置（--uts） --uts=&quot;&quot; : 设置容器的 UTS 命名空间。可选值：host 值代表使用主机的 uts 值。 UTS 命名空间参数设置旨在使容器进程对于运行于目标 uts 设置中的目标进程的主机名和域可见。默认情况下所有的容器，包括指定了 --network=host 命名空间的容器，都有自己的 uts 命名空间。--uts=host 将会使容器使用和主机一样的 uts 命名空间。在指定了 --uts=host 设置后将不能再单独指定 --hostname 和 --domainname 设置。 如果希望容器的主机名随着主机的主机名的更改而更改，即容器与主机共享主机名，更好的做法是从容器中更改主机的主机名。 IPC 设置（--ipc） --ipc=&quot;MODE&quot; : 设置容器的 IPC 模式 可以接受以下值： 值 描述 不指定 使用守护程序默认设置 none 使用自己私有的 IPC 命名空间，且不挂载 /dev/shm private 使用自己私有的 IPC 命名空间 shareable 使用自己私有的 IPC 命名空间，但允许与其他容器共享此命名空间 container: &lt;_name-or-ID_&gt; 加入其他设置了 --ipc=shareable 的容器的命名空间（需指定容器名或 ID） host 使用主机的 IPC 命名空间 dockerd 守护程序默认会使用 --ipc=private 或 --ipc=shareable 设置，具体取决于 dockerd 守护程序的版本及配置。 IPC(POSIX/SysV IPC) 命名空间提供了不同命名空间下的共享内存段、信号量以及消息队列的隔离机制。 共享内存段是用于以内存的速度加速进程间通信的一种方法，除此之外还有通过管道或网络堆栈的方法。共享内存通常用于涉及科学计算或金融服务等的数据库和构建的对高性能有要求的应用程序。如果你的这类应用程序被拆分成多个容器就要考虑可能需要共享这些容器之间的 IPC 机制，做法是对主容器使用 --ipc=shareable 的设置、其他容器使用 --ipc=container:&lt;主容器名或其 ID&gt; 的设置。 网络设置 --dns=[] : 为容器指定域名服务器 --network=&quot;bridge&quot; : 指定容器接入网络的方式，可选值：bridge 在默认的 Docker 网桥上创建网络栈（默认）；none 不联网；container:&lt;name|id&gt; 复用现有容器的网络栈；host 使用 Dockr 主机的网络栈；&lt;network-name&gt;|&lt;network-id&gt; 连接至用户自定义的网络。 --network-alias=[] : 为容器添加网络范围的别名 --add-host=&quot;&quot; : 在 /etc/hosts 上自动添加一行记录 (host:IP) --mac-address=&quot;&quot; : 指定容器物理设备的 MAC 地址 --ip=&quot;&quot; : 指定容器物理设备的 IPv4 地址 --ip6=&quot;&quot; : 指定容器物理设备的 IPv6 地址 --link-local-ip=[] : 指定一个或多个容器的物理设备的链路的本地 IPv4 或 IPv6 地址 默认情况下，所有容器都会启用网络且对网络出口不做任何限制。可以通过指定 --network none 选项来禁用容器的网络，在这种情况下，可以仅通过文件、标准输入输出流来进行 I/O。 要实现不同容器之间的互通只能通过默认的网桥模式设置，链接特性是一种经典的特性，更推荐使用基于链接特性的 Docker 网络驱动。 你的容器会默认使用主机设置的 DNS 服务器，但是你可以通过指定 --dns=&lt;DNS&gt; 选项来指定容器网络的 DNS 设置。 默认情况下，容器会根据自身分配的 ip 地址来生成自己的 MAC 地址，可以通过指定 --mac-address=&lt;MAC&gt; 选项（MAC 地址的分隔符使用英文冒号，如 12:34:56:78:9a:bc）来显式指定容器的 MAC 地址。需注意 Docker 不会进行手动分配的 MAC 地址的唯一性检查。 Network:none 容器不会有到外部网络的虚拟设备及路由，但内部仍会有一个回环接口。 Network:bridge 将网络设置为桥接模式后，容器将使用 docker 的默认网络设置。在主机上设置一个桥，通常命名为 docker0，将为容器创建一对 veth 接口。veth对的一端将保留在连接到网桥的主机上，而 veth 对的另一端除了放在环回接口之外，还将放在容器的命名空间内以为网桥网络上的容器分配一个IP 地址，流量将通过该网桥路由到该容器。 默认情况下，容器可以通过它们的 IP 地址进行通信。要通过名字交流，它们必须连接在一起。 Network:host 将网络设置为主机模式后，容器将共享主机的网络堆栈，并且来自主机的所有接口将对容器可用。容器的主机名将与主机系统上的主机名相匹配。请注意 --mac-address 选项在主机网络模式下无效。即使在主机网络模式下，默认情况下容器也有自己的 UTS 命名空间。因此，在主机网络模式下允许使用 --hostname 和 --domainname 选项，它们只会更改容器内的主机名和域名。与 --hostname 类似，可以在主机网络模式下使用 --add-host、--dns、--dns-search 和 --dns-option 选项。这些选项将会更新容器中的 /etc/hosts 或 /etc/resolv.conf。不会对主机上的 /etc/hosts 和 /etc/resolv.conf 进行任何更改。 与默认网桥模式相比，主机模式提供了明显更好的网络性能，因为它使用主机的本机网络堆栈，而网桥必须通过 dockerd 守护程序经历一级虚拟化。当容器的网络性能至关重要时，例如生产负载平衡器或高性能 Web 服务器，建议以此模式运行容器。 🔵 注意：--network=&quot;host&quot; 给予容器对本地系统服务（如 D-bus）的完全访问权，因此被认为是不安全的。 Network:container 将网络设置为容器模式后，一个容器将共享另一个容器的网络堆栈。另一个容器的名称必须以 --network container:&lt;名称|id&gt; 的格式提供。注意 --add-host、--hostname、--dns、--dns-search、--dns-option 和 --mac-address 在容器网络模式中无效，而 --publish、--publish-all、--expose 在容器网络模式中也无效。 以下示例运行 redis 容器，将 redis 绑定到本地主机，然后运行 redis-cli 命令并通过本地主机接口连接到Redis服务器。 12\\$ docker run -d --name redis example/redis --bind 127.0.0.1\\$ docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1 用户定义的网络 你可以使用 Docker 网络驱动程序或外部网络驱动程序插件来创建网络。你可以将多个容器连接到同一网络。一旦连接到用户定义的网络，这些容器就可以仅使用另一个容器的 IP 地址或域名轻松地进行通信。 对于支持多主机连接的覆盖网络或自定义插件，连接到同一多主机网络但从不同引擎启动的容器也可以通过这种方式进行通信。 以下示例使用内置网桥网络驱动程序创建网络，并在创建的网络中运行容器： 12\\$ docker network create -d bridge my-net\\$ docker run --network=my-net -itd --name=container3 busybox 管理 /etc/hosts 文件 你的容器将在 /etc/hosts 中包含一些行，这些行定义了容器本身的主机名以及 localhost 和其他一些常见内容。--add-host 标志可用于向 /etc/hosts 添加额外的行。 123456789\\$ docker run -it --add-host db-static:86.75.30.9 ubuntu cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters86.75.30.9 db-static172.17.0.2 af78fbac55c9 如果一个容器连接到默认桥接网络并与其他容器链接，则该容器的 /etc/hosts 文件将使用链接容器的名称进行更新。 🔵 注意：由于 Docker 可能会实时更新容器的 /etc/hosts 文件，因此可能会出现容器内的进程最终读取空的或不完整的 /etc/hosts 文件的情况。在大多数情况下，再次重试读取应该可以解决问题。 重启策略（--restart） 使用 docker run 上的 --restart 标志可以指定容器的重启策略，决定容器在退出时应不应该以及如何重启。 当重启策略在容器上被激活时，它将在 docker ps 中显示为 Up 或 Restarting。使用 docker events 查看重启策略的效果也很有用。 策略 效果 no （默认）容器退出后不会自动重启。 on-failure[:max-retries] 当容器退出并返回一个非零状态值时尝试重启，可以指定最大重试次数。 always 无论退出状态如何，都要重启容器。当指定 always 时，Docker 守护进程将尝试无限期地重新启动容器。无论容器的当前状态如何，容器也总是在守护进程启动时启动。 unless-stopped 无论退出状态如何，都要重启容器，包括在守护进程启动时，除非容器在 Docker 守护进程停止之前处于停止状态。 在每次重新启动之前，增加延迟(从 100 毫秒开始，是之前延迟的两倍),以防止服务器洪流。这意味着守护进程将等待 100 毫秒，然后 200 毫秒，400，800，1600，等等，直到达到失败极限，最大延迟1分钟，或者当您执行 docker stop 或 docker rm -f 容器。 如果容器成功重启(容器启动并运行至少 10 秒)，延迟将重置为默认值100毫秒。 使用失败时策略时，您可以指定 Docker 尝试重新启动容器的最大次数。默认情况下，Docker 将永远尝试重新启动容器。可以通过 docker inspect 获得容器的(尝试)重启次数。例如，获取容器“my-container”的重启次数: 1\\$ docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; my-container 或者获得上次容器(重新)启动的时间: 1\\$ docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; my-container 将 --restart (重新启动策略)与 --rm (清理)标志结合使用会导致错误。容器重启时，连接的客户端会断开连接。 自动清理（--rm） 默认情况下，容器的文件系统即使在容器退出后仍然存在。这使得调试容易得多(因为您可以检查最终状态),并且在默认情况下保留所有数据。但是如果你运行的是短期前台进程，这些容器文件系统会不断堆积起来。相反，如果您希望 Docker 在容器退出时自动清理容器并删除文件系统，您可以添加 --rm 标志: --rm=false: 容器退出时自动清理","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"RHCE 考试及红帽企业 Linux 了解","slug":"Linux | RHCE 考试及红帽企业 Linux 了解","date":"2022-03-01T10:35:41.028Z","updated":"2022-03-05T12:58:15.221Z","comments":true,"path":"2022-03-01-Linux | RHCE 考试及红帽企业 Linux 了解.html","link":"","permalink":"https://skinyi.github.io/2022-03-01-Linux%20|%20RHCE%20%E8%80%83%E8%AF%95%E5%8F%8A%E7%BA%A2%E5%B8%BD%E4%BC%81%E4%B8%9A%20Linux%20%E4%BA%86%E8%A7%A3.html","excerpt":"","text":"🔴 此文章由之前的 Typora 笔记迁移过来，内容可能已经过时。 RHCE8.0 课程及考试代码 相较于 RHCE7 ，在 EX200 考试中，RHCE8 增加了 SHELL 脚本（RH254）、系统调优（RH442）以及 RHEL8 新特性的一些考察；在 EX294 考试中，RHCE7 考察一些常见的 Service 的搭建部署使用，如：NFS、SAMBA、DNS等，而在 RHCE8 考试中则主要考察 Ansible 自动化工具的操作，不再包含常见服务。 课程代码 考试代码 考试内容 考试形式 考试时长 RH124 EX200 以系统管理操作为主，如：文件系统、用户操作、权限操作、磁盘操作等 机考实验 2.5h RH134 RH294 EX294 全是关于 Ansible 自动化工具的技能操作 4h 搭建日常练习环境 🟢 所需前期准备工作： 已安装 VMWare Workstation 虚拟机，并在 bios 中开启了虚拟化相关的开关； 已下载好 RHEL8 Linux 操作系统 iso 镜像； 练习环境虚拟机以 NAT 模式和宿主机进行网络连接，使用的虚拟网卡是 VMNet8 。 虚拟机安装 RHEL8.3 操作系统 ​如图，虚拟机的配置如下，可根据自己个人硬件设备情况按需调整。 虚拟机软件选择如下： 设置 root 用户和普通用户后开始安装，等待进度条跑完重启虚拟机，重启后同意 Redhat 的 EULA，选择 FINISH CONFIGURATION 进入图形界面。图形界面默认为刚才创建的普通用户，新安装的 RHEL 还需要进行一些系统级的配置才行。 在此之前我们需要登陆 root 账户来配置我们新安装的操作系统。下图为使用 root 用户登陆后的界面。 安装完操作系统后的配置 配置网络设置 ​使用 ip addr show 命令来查看操作系统的网络配置结果如图所示： 🟢 其它网卡设备介绍： lo 虚拟网卡设备， lo 是主机用于向自身发送通信的一个特殊地址（也就是一个特殊的目的地址），其 ip 为 127.0.0.1 ； virbr0 是 KVM 默认创建的一个网桥，其作用是为连接其上的虚拟机网卡提供 NAT 访问外网的功能，可提供 DHCP 服务，其默认 ip 为 192.168.122.1。此虚拟设备被强制删除后重启系统还会再次创建，如需卸载须使用 KVM 虚拟化管理工具； birbr0-nic, 同上由 KVM 服务创建，可以使用 brctl 命令进行管理。 其中 ens160 才是连接外网所需要的网卡设备。可以看到此网卡没有绑定 ip 地址，但虚拟机软件是设置的 NAT 且已开启了 DHCP 服务，因此导致此问题的原因可能是我们的网卡设备没有启动或启用。需要检查此网卡设备的配置文件，其路径为：/etc/sysconfig/network-scripts/ifcfg-ens160（可以推断 RHEL 的网卡配置文件名称都是由 &quot;ifcfg-&quot; 和网卡名组成的），使用 vim 编辑器来编辑此文件，此文件内容如下： 123456789101112131415TYPE=Ethernet # 网络类型：以太网PROXY_METHOD=none # 网络代理方法BROWSER_ONLY=no BOOTPROTO=dhcp # 激活设备使用的地址配置协议：dhcp,static,none,bootpDEFROUTE=yes # ipv4 默认路由设备：yes,noIPV4_FAILURE_FATAL=noIPV6INIT=yes # 初始化 ipv6 协议栈：yes,noIPV6_AUTOCONF=yes # 自动配置 ipv6：yes,noIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens160 # 网卡名UUID=74e066fb-4f82-4422-ae3f-570dd2fca5a5 DEVICE=ens160 # 应用到的设备（和 HWADDR 必须留一个，后者指网卡物理地址）ONBOOT=no # 开机后自动激活此设备 🟢 Linux 网络配置说明： 网卡的相关配置文件：/etc/sysconfig/network-scripts/ifcfg-网卡名 路由相关的配置文件：/etc/sysconfig/network-scripts/route-网卡名 网络相关说明参考/usr/share/doc/initscripts-version/sysconfig.txt 需要将 ONBOOT=no 更改为 ONBOOT=yes 以使此网卡开机就激活启用，重启虚拟机，验证网卡是否已经自动激活（自动获得了 ip 地址则配置成功）。 使用 Xshell 远程登陆 ​在 Xshell 里新建连接，进行配置即可远程登陆到此虚拟机。 RHEL 和 CentOS 的区别 简称 中文全称 存在付费 付费回报 特点 RHEL 红帽企业 Linux 操作系统 是 获得技术支持 稳定，最先获得 Bug 修复 CentOS 社区企业操作系统 否 - 含有一些新特性，比较稳定，延迟获得 Bug 修复","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"学习/Linux","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Linux/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"迁移文章","slug":"迁移文章","permalink":"https://skinyi.github.io/categories/%E8%BF%81%E7%A7%BB%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"RHEL","slug":"RHEL","permalink":"https://skinyi.github.io/tags/RHEL/"},{"name":"RHCE","slug":"RHCE","permalink":"https://skinyi.github.io/tags/RHCE/"},{"name":"认证考试","slug":"认证考试","permalink":"https://skinyi.github.io/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"}]},{"title":"Docker 命令手册及常用帮助命令","slug":"Docker | Docker 命令手册及常用帮助命令","date":"2022-02-27T14:03:20.637Z","updated":"2022-03-01T13:16:25.044Z","comments":true,"path":"2022-02-27-Docker | Docker 命令手册及常用帮助命令.html","link":"","permalink":"https://skinyi.github.io/2022-02-27-Docker%20|%20Docker%20%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"常用命令速查表格 命令 用途 docker version 查看 docker 客户端及服务端（docker 引擎）的版本及环境信息 docker info 查看 docker 的系统信息，包括客户端、服务端配置、镜像与容器数量以及一些其他常见配置 docker [命令] --help 查看 docker [命令] 使用的帮助信息，比如 docker image --help Docker 命令速查手册地址：https://docs.docker.com/engine/reference/run/ 。 常用帮助命令介绍 docker version 查看 docker 版本信息 12345678910111213141516171819202122232425262728293031[skinyi@fedora ~]\\$ sudo docker version[sudo] skinyi 的密码：Client: Docker Engine - Community Version: 20.10.12 API version: 1.41 Go version: go1.16.12 Git commit: e91ed57 Built: Mon Dec 13 11:46:03 2021 OS/Arch: linux/amd64 Context: default Experimental: trueServer: Docker Engine - Community Engine: Version: 20.10.12 API version: 1.41 (minimum version 1.12) Go version: go1.16.12 Git commit: 459d0df Built: Mon Dec 13 11:43:48 2021 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.4.12 GitCommit: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc: Version: 1.0.2 GitCommit: v1.0.2-0-g52b36a2 docker-init: Version: 0.19.0 GitCommit: de40ad0 docker info 查看 docker 的系统信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[skinyi@fedora ~]\\$ sudo docker info[sudo] skinyi 的密码：Client: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Docker Buildx (Docker Inc., v0.7.1-docker) scan: Docker Scan (Docker Inc., v0.12.0)Server: Containers: 2 Running: 0 Paused: 0 Stopped: 2 Images: 1 Server Version: 20.10.12 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: true userxattr: false Logging Driver: json-file Cgroup Driver: systemd Cgroup Version: 2 Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc io.containerd.runc.v2 io.containerd.runtime.v1.linux Default Runtime: runc Init Binary: docker-init containerd version: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc version: v1.0.2-0-g52b36a2 init version: de40ad0 Security Options: seccomp Profile: default cgroupns Kernel Version: 5.16.8-200.fc35.x86_64 Operating System: Fedora Linux 35 (Server Edition) OSType: linux Architecture: x86_64 CPUs: 2 Total Memory: 3.788GiB Name: fedora ID: I5R6:5NIE:OTIL:XBI4:R6WP:5XSO:BZTG:QGV6:6RHG:OU7U:P3EP:JTEC Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false docker [命令] --help 查看 docker [命令] 的帮助信息 123456789101112131415161718192021[skinyi@fedora ~]\\$ docker image --helpUsage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGERun &#x27;docker image COMMAND --help&#x27; for more information on a command. 123456789101112131415161718[skinyi@fedora ~]$ sudo docker container list --helpUsage: docker container ls [OPTIONS]List containersAliases: ls, ps, listOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don&#x27;t truncate output -q, --quiet Only display container IDs -s, --size Display total file sizes docker 子命令功能简介 子命令 描述 docker attach 将本地标准输入输出和错误流附加到正在运行的容器 docker build 从 Dockerfile 构建一个镜像 docker builder 管理镜像构建器 docker checkpoint 管理检查点 docker commit 从一个容器的所有更改创建一个新的镜像 docker config 管理 Docker 的配置 docker container 管理容器 docker context 管理 docker 上下文 docker cp 在容器和本地存储之间拷贝文件或目录 docker create 创建一个新的容器 docker diff 监视容器上的文件或目录的变化 docker events 从 docker 守护服务上获取实时事件 docker exec 在一个运行的容器上运行命令 docker export 将一个容器的文件系统以 tar 包的形式导出 docker history 展示一个镜像的提交历史 docker image 管理 docker 镜像 docker images 列出镜像 docker import 从 tar 包中导入内容来创建一个文件系统镜像 docker info 显示系统范围的信息 docker inspect 返回 docker 对象的底层信息 docker kill 杀掉一个或多个运行中的容器 docker load 从一个 tar 包或标准输入来加载镜像 docker login 登录 Docker registry docker logout 登出 Docker registry docker logs 获取一个容器的日志 docker manifest 管理 Docker 镜像清单和清单列表","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"Docker 介绍以及安装与卸载","slug":"Docker | Docker 介绍以及安装与卸载","date":"2022-02-27T13:03:47.405Z","updated":"2022-03-21T06:22:59.708Z","comments":true,"path":"2022-02-27-Docker | Docker 介绍以及安装与卸载.html","link":"","permalink":"https://skinyi.github.io/2022-02-27-Docker%20|%20Docker%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html","excerpt":"","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的 Linux 或 Windows 操作系统的机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 Docker 官方文档地址：https://docs.docker.com/。在其官网上关于 docker 的整体架构介绍可以找到这张图： 可以看出 docker 整体是模块化、低耦合且遵循 C/S 架构的，构成它的是功能不同的组件，以下是对这些组件的功能的梳理。 Docker 组件介绍 Docker Daemon：Docker 守护进程（dockerd）监听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和存储卷。守护进程还可以与其他守护进程通信以管理 Docker 服务。 Docker Client：Docker 客户端（docker）是许多 Docker 用户与 Docker 交互的主要方式。当你使用 docker run 等命令时，客户端会将这些命令发送给 dockerd，dockerd 会执行这些命令。 docker 命令使用 Docker API。Docker 客户端可以与多个守护进程通信。 Docker Desktop：是一个易于安装的应用程序，适用于 Mac 或 Windows 环境，能够构建和共享容器化应用程序和微服务。Docker Desktop 包括 Docker 守护程序 (dockerd)、Docker 客户端 (docker)、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。有关更多信息，请参阅 Docker 桌面。 Docker Registries：Docker 仓库存储 Docker 映像（Docker Image）。DockerHub 是一个任何人都可以使用的公共仓库，并且 Docker 默认配置为在 DockerHub 上查找镜像。甚至可以定制运行自己的私有仓库。 当使用 docker pull 或 docker run 命令时，将从系统所配置的镜像仓库中提取所需的镜像。当使用 docker push 命令时，你定制的镜像会被推送到你配置的镜像仓库中。 Docker Objects：当使用 Docker 时，会涉及到创建和使用图像、容器、网络、卷、插件和其他对象。以下简要概述其中一些对象。 Docker Image Docker 镜像是一个只读模板，其中包含创建 Docker 容器时的说明。通常，一个镜像基于另一个镜像，并附带有一些额外的自定义。例如，可以构建一个基于 ubuntu 镜像的镜像，但会安装 Apache Web 服务器和一些你的应用程序，该镜像还包含使你的应用程序运行所需的配置的详细信息。 你可以创建自己的镜像，也可以只使用其他人创建并在仓库中发布的镜像。要构建你自己的镜像，你需要使用简单的语法创建一个 Dockerfile，用于定义创建和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层。当你更改 Dockerfile 并重建映像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻量、小巧和快速的部分原因。 Docker Container Docker 容器是镜像的可运行实例。你可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。你可以将容器连接到一个或多个网络，将存储附加到它，甚至可以根据其当前状态创建新的镜像。 默认情况下，一个容器与其他容器以及其宿主机的隔离相对较好。你可以控制容器的网络、存储和其他底层子系统与其他容器或宿主机的隔离程度。 一个容器由其镜像以及你在创建或启动它时提供给它的任何配置选项进行定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。 ​Docker 三大核心组件指的是：Docker Image、Docker Container 以及 Docker Registry。 Docker 运行示例 以下命令运行 ubuntu 容器，以交互方式附加到本地命令行会话，并运行 /bin/bash。 1[skinyi@fedora ~]\\$ sudo docker run -i -t ubuntu /bin/bash ^ 安装 Docker 后如不做其他配置则 docker run 命令只能使用 root 权限来执行。 当你运行此命令时，会发生以下情况（假设你使用的是默认镜像仓库配置）： 如果你在本地没有 ubuntu 映像，Docker 会从你配置的镜像仓库（默认 DockerHub）中提取它，就像你手动运行 docker pull ubuntu 一样； Docker 使用该镜像创建一个新容器，就像你手动运行了 docker container create 命令一样； Docker 为该容器分配一个读写文件系统，作为该容器的底层，这允许正在运行的容器在其本地文件系统中创建或修改文件和目录； 由于没有指定任何其他的网络选项，Docker 会创建一个网络接口来将该容器连接到默认网络，包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。 Docker 启动容器并执行 /bin/bash。由于容器以交互方式运行并附加到您的终端（-i 和 -t 选项），所以你可以在将输出记录到终端时使用键盘提供输入。 当你键入 exit 命令以终止 /bin/bash 命令时，容器会停止但不会被删除，你可以重新启动或删除它。 Docker 的安装与卸载 个人学习使用操作系统为：Fedora 35，Fedora 版本目前仅支持 Fedora 34 和 Fedora 35。 12345678910111213141516171819202122[skinyi@fedora ~]\\$ cat /etc/os-releaseNAME=&quot;Fedora Linux&quot;VERSION=&quot;35 (Server Edition)&quot;ID=fedoraVERSION_ID=35VERSION_CODENAME=&quot;&quot;PLATFORM_ID=&quot;platform:f35&quot;PRETTY_NAME=&quot;Fedora Linux 35 (Server Edition)&quot;ANSI_COLOR=&quot;0;38;2;60;110;180&quot;LOGO=fedora-logo-iconCPE_NAME=&quot;cpe:/o:fedoraproject:fedora:35&quot;HOME_URL=&quot;https://fedoraproject.org/&quot;DOCUMENTATION_URL=&quot;https://docs.fedoraproject.org/en-US/fedora/f35/system-administrators-guide/&quot;SUPPORT_URL=&quot;https://ask.fedoraproject.org/&quot;BUG_REPORT_URL=&quot;https://bugzilla.redhat.com/&quot;REDHAT_BUGZILLA_PRODUCT=&quot;Fedora&quot;REDHAT_BUGZILLA_PRODUCT_VERSION=35REDHAT_SUPPORT_PRODUCT=&quot;Fedora&quot;REDHAT_SUPPORT_PRODUCT_VERSION=35PRIVACY_POLICY_URL=&quot;https://fedoraproject.org/wiki/Legal:PrivacyPolicy&quot;VARIANT=&quot;Server Edition&quot;VARIANT_ID=server Fedora 操作系统 Docker 安装文档：https://docs.docker.com/engine/install/fedora/。 卸载旧版本 12345678[skinyi@fedora ~]\\$ sudo dnf remove docker \\ docker-client \\ docker-client-lastest \\ docker-common \\ docker-lastest-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 使用软件仓库进行 Doker 的安装 ​安装 dnf-plugins-core 插件。 1[skinyi@fedora ~]$ sudo dnf -y install dnf-plugins-core ​添加 docker 的官方软件仓库。 12[skinyi@fedora ~]$ sudo dnf config-manager --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo 安装 Docker 引擎 1[skinyi@fedora ~]$ sudo dnf install docker-ce docker-ce-cli containerd.io 启动并验证 Docker 是否成功安装 1234567891011121314151617181920212223[skinyi@fedora ~]$ sudo systemctl start docker[skinyi@fedora ~]$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 实现非 root 权限执行 docker 命令或者实现一些其他安装后的优化可以参阅：https://docs.docker.com/engine/install/linux-postinstall/。 卸载 Docker 引擎 12[skinyi@fedora ~]$ sudo dnf remove docker-ce docker-ce-cli containerd.io[skinyi@fedora ~]$ sudo rm -rf /var/lib/docker /var/lib/containerd 启动 Docker 时的执行过程 启动过程中的注意点： Docker 优先使用的存储驱动为 Overlay2； 加载容器时会设置容器的网络，并创建虚拟网络接口 docker0，该接口使用桥接模式接入网络，并在宿主机防火墙中配置一个 docker zone； Docker 的守护程序 dockerd 初始化成功后会启动 docker 应用容器引擎，然后 docker 引擎通过监听 /run/docker.sock 套接字实现客户端与守护程序之间的通信。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"使用 Hexo 搭建个人博客","slug":"Hexo | 使用 Hexo 搭建个人博客","date":"2022-02-21T14:23:11.437Z","updated":"2022-03-30T07:56:22.109Z","comments":true,"path":"2022-02-21-Hexo | 使用 Hexo 搭建个人博客.html","link":"","permalink":"https://skinyi.github.io/2022-02-21-Hexo%20|%20%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html","excerpt":"","text":"一直以来都有搭建个人网站或者说博客的想法，今天终于把这件事做成了，感谢 Github 各大代码托管平台的 GitHub XXX Pages 服务，使我们即使没有公网服务器也能搭个人人可访问的静态个人网站，而且无需任何费用。当然国内码云也有这项服务，由于一些理由我没有在那上面弄， Github Pages 由于国内访问速度太慢了，我就在码云上面也创建了仓库，然而启用 Pages 功能需要实名认证。言归正传，按照 Hexo 社区的惯例以及正好作为自己对搭建个人网站过程的记录，我的个人网站上的第一篇文章就打算写写这个搭建博客的过程。 准备工作 搭建博客所需的环境和官网地址如下： 名称 作用 官网 Nodejs Hexo 博客框架依赖的开发环境 https://nodejs.org/en/ Git 推送博客至 github 或其他一些代码托管 https://git-scm.com/ Hexo 快速、简洁且高效的博客框架 https://hexo.io/zh-cn/ Purer theme 一款简洁高效的响应式个人博客主题 https://github.com/fengkx/hexo-theme-purer 博客系统平台环境搭建在我的 Fedora 35 虚拟机上。 12[skinyi@localhost ~]$ uname -aLinux localhost.localdomain 5.16.9-200.fc35.x86_64 #1 SMP PREEMPT Fri Feb 11 16:29:17 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux 安装步骤 我非常建议你按照我上面所给的表格来访问官方文档来分步进行部署。官方文档永远不会过时而且详尽，会最大程度上解决你的疑虑。以下是我对此次部署过程的一次记录，其中会着重记录我的部署过程中踩过的一些坑。 安装 Nodejs 使用 Linux 系统我个人比较倾向于从软件仓库获得软件，但是软件仓库里的软件不一定会是最新版的，但是这种方式可以使我们省去自己编译、配置的时间。Nodejs 官网上的下载页面里的 Linux 二进制版本是压缩包，要从软件仓库获得它的话需要点击下面的 Installing Node.js via package manager 链接来查阅官方文档。 根据文档的描述，Fedora 35 可以通过安装 dnf 软件模块的方式来进行安装，可以先看看仓库里已有的软件流版本： 1234567891011121314151617[skinyi@localhost ~]$ dnf module list nodejs上次元数据过期检查：0:08:01 前，执行于 2022年02月23日 星期三 18时50分04秒。Fedora Modular 35 - x86_64Name Stream Profiles Summary nodejs 12 default, development, minimal Javascript runtime nodejs 14 default, development, minimal Javascript runtime nodejs 15 default, development, minimal Javascript runtime nodejs 16 default, development, minimal Javascript runtime Fedora Modular 35 - x86_64 - UpdatesName Stream Profiles Summary nodejs 12 default, development, minimal Javascript runtime nodejs 14 common, development, minimal Javascript runtime nodejs 15 default, development, minimal Javascript runtime nodejs 16 [e] common, development, minimal Javascript runtime 提示：[d]默认，[e]已启用，[x]已禁用，[i]已安装 Hexo 官方文档中建议 Nodejs 版本使用 Nodejs 12.0 及以上版本的，在这里我选择安装 Nodejs 16 版本的。 1[skinyi@localhost ~]$ sudo dnf module install nodejs:16 安装完成后查看 Nodejs 版本号： 12[skinyi@localhost ~]$ node -vv16.14.0 从仓库安装完成后，需要升级 npm 版本以及为了不用以 root 权限执行 npm 命令，需要更改 npm 的配置： 1234# 在当前用户主目录创建 npm 全局安装目录[skinyi@localhost ~]$ mkdir ~/.npm-global# 配置 npm 使用刚才建的目录路径[skinyi@localhost ~]$ npm config set prefix &#x27;~/.npm-global&#x27; 添加 ~/.npm-global/bin 路径到用户环境变量： 12[skinyi@localhost ~]$ echo &#x27;export PATH=~/.npm-global/bin:$PATH&#x27; &gt;&gt; ~/.bash_rc[skinyi@localhost ~]$ source ~/.bash_rc 安装Git 使用 dnf 包管理器安装 Git： 1[skinyi@localhost ~]$ sudo dnf install git-core git 全局配置，如果需要通过 git 将博客部署到 Github Pages 上，需要配置 git 的一些全局设置： 12[skinyi@localhost ~]$ git config --global user.name &quot;github 上的用户名&quot;[skinyi@localhost ~]$ git config --global user.email &quot;注册 github 账号使用的邮箱&quot; 安装 Hexo 以上依赖软件安装成功后，就可以进行 Hexo 的安装了： 1[skinyi@localhost ~]$ npm install -g hexo-cli 在工作目录里初始化自己的博客项目： 1234[skinyi@localhost ~]$ hexo init blog[skinyi@localhost ~]$ cd blog[skinyi@localhost ~]$ npm install[skinyi@localhost ~]$ hexo server 可以通过浏览器访问本地地址：http://127.0.0.1:4000 来预览生成的博客网站，若要在外部访问的话需要通过防火墙开放 4000 端口，在此不再赘述。 更换博客主题 从 Hexo 主题列表里筛选了一圈后我终于选中了此时用的这款主题，它的 Github 链接是：https://github.com/fengkx/hexo-theme-purer ，如果你也喜欢这款主题，可以通过项目主页的的说明文档来了解它的安装、配置及使用，不过建议你在看作者的文档前先大致看下 Hexo 的使用文档来了解了解 Hexo 的一些基本概念，这样看作者的文档再上手就比较容易了。 这款主题是基于 EJS 和 Tailwind CSS 构建的，以后若有兴趣构建自己的主题可以参考使用这两种技术。 下载主题文件 我没有按照官方使用 git clone 同步的方法来下载主题，直接通过下载仓库源码的方式下载下来。gh-pages 是我的整个博客项目的主目录。 123[skinyi@localhost gh-pages]$ wget -c https://github.com/fengkx/hexo-theme-purer/archive/refs/heads/master.zip -O themes/[skinyi@localhost gh-pages]$ unzip themes/master.zip[skinyi@localhost gh-pages]$ mv themes/hexo-theme-purer-master themes/purer 文档中为了避免由于主题更新而导致原有的主题目录下的 _config.yml 文件失效故而选择把主题的 _config.yml 放在主题外面并取名为 _config.theme.yml，在进行编译时将此文件的内容写进主题底下的 _config.yml。虽然我之后不会更新这个主题但是我还是按照文档里的做了，只不过我起的名字为 _config.purer.yml。 将 purer 主题下的 _config.example.yml 复制到项目主目录下。然后编辑 package.json 的内容如下： 12[skinyi@localhost gh-pages]$ cp themes/purer/_config.example.yml _config.purer.yml[skinyi@localhost gh-pages]$ code package.json package.json123456789&#123; &quot;scripts&quot;: &#123; &quot;theme&quot;: &quot;cat ./_config.purer.yml &gt; ./themes/purer/_config.yml &quot;, &quot;build&quot;: &quot;npm run theme &amp;&amp; hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;npm run theme &amp;&amp; hexo deploy&quot;, &quot;server&quot;: &quot;npm run theme &amp;&amp; hexo server&quot; &#125;,&#125; 配置主题 安装及配置插件 首先可选的工作是卸载不需要或不推荐的渲染器： 12[skinyi@localhost gh-pages]$ npm uninstall hexo-renderer-stylus[skinyi@localhost gh-pages]$ npm uninstall hexo-renderer-marked 安装 markdown-it 渲染器以及其他常用插件： 12345678# markdown-it 渲染器[skinyi@localhost gh-pages]$ npm i -S hexo-renderer-markdown-it# 支持从post_assert_folder 用 markdown 引入图片[skinyi@localhost gh-pages]$ npm i -S hexo-asset-image# 支持 emoji[skinyi@localhost gh-pages]$ npm i -S markdown-it-emoji# 支持数学公式[skinyi@localhost gh-pages]$ npm i -S @iktakahiro/markdown-it-katex 由于 hexo-renderer-markdown-it 默认不生成 h1 的锚点，所以我们需要在站点配置文件添加如下设置，在插件对象里将刚才添加的两个插件加进去: _config.yml123456789101112131415markdown: html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ anchors: level: 1 permalink: false separator: &#x27;-&#x27; plugins: - &#x27;@iktakahiro/markdown-it-katex&#x27; - markdown-it-emoji 创建常见页面 在 项目主目录/source 下按需添加 categories、tags、repositories、links、about 目录，这些分别对应博客框架中的分类页、标签页、仓库页（主题独有）、友链页、关于页。然后在其中创建对应的 index.md 文件。 我的项目没有要友链页，故最终目录结构如下： 12345678910111213141516171819[skinyi@localhost gh-pages]$ tree -L 2 sourcesource├── about│ └── index.md├── categories│ └── index.md├── images│ ├── avatar.jpg│ └── favicon.png├── _posts│ ├── 使用 Hexo 搭建个人博客.md│ └── images├── README.md├── repository│ └── index.md└── tags └── index.md7 directories, 8 files 如果你事先看过 Hexo 的文档，你就会知道 _post 目录存放的是写好的文章以及我们刚刚创建的 index.md 需要添加 front-matter。以内容稍微多的 about 目录的 front-matter 为例： 1234567---title: 关于description: 个人简介layout: aboutsidebar: customdate: 2022-02-22 20:55:00--- 其他目录的 front-matter 可以参考主题作者文档中的 Demo 链接。 定制主题配置 接下来需要修改项目主目录下的 _config_purer.yml 文件来定制自己的主题，这个参照主题文档按照自己的心意定制就成，我没有要友链和书单页面。 写作 所有已经发表的文章都在项目目录的 source/_posts 子目录下，Hexo 同样支持添加草稿，草稿目录里的文章默认不会渲染出来。对我来说懒得使用草稿了，因为吹牛根本不需要打草稿。我比较喜欢 VSCode 里边写边想，写完后再部署就可以了，根本不需要草稿。 博文是以 markdown 格式编写的，好在这门语言的学习成本并不高，多写多用多记就可以满足大部分使用需要，比较冷门的格式需要用的时候再查也花费不了太长时间。 部署文章 博客网站搭建起来了需要部署到公网上才能被他人看到，但是公网 IP 以及服务器需要花费不小的经济成本，好在一些代码托管网站都提供了 XXX Pages 服务。需要注意的是：在国内的平台上启用 Pages 服务一般都需要进行实名认证，而在 Github Pages 上部署不需要进行实名。 使用 git 的方式进行博客部署可以安装 hexo 插件 hexo-deployer-git： 1[skinyi@localhost gh-pages]$ npm install hexo-deployer-git --save 在 _config.yml 中修改配置： 1234567deploy: type: git repo: github: &lt;github 仓库地址&gt; # 如 https://github.com/xxx/xxx.github.io gitee: &lt;gitee 仓库地址&gt; # 如 https://gitee.com/xxx/xxx branch: [代码分支] # 如 master message: [提交信息] 生成站点文件并推送至远程仓库： 1[skinyi@localhost gh-pages]$ hexo clean &amp;&amp; hexo deploy 通过 Git 方式提交时建议在本地生成公私钥对并将生成的公钥文件添加到远程仓库的公钥列表里，然后每次提交时就可以通过验证公私密钥对的方式而不用每次都输用户名及密码。 到这里基本算是介绍完了所有的搭建步骤，之后我会把我在 Typora 里写的所有学习笔记都搬运到这个博客中，当然这个网站的内容并不局限于一些跟技术相关的东西，我并不确定我写的这些东西会不会有人看，我也打算写一些技术博客以外的东西，不管以后怎么样、写些什么，就活在当下、享受并记录生活吧。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"杂项","slug":"学习/杂项","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://skinyi.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://skinyi.github.io/tags/Nodejs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://skinyi.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://skinyi.github.io/tags/Markdown/"}]}],"categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"生活","slug":"生活","permalink":"https://skinyi.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"驾驶","slug":"生活/驾驶","permalink":"https://skinyi.github.io/categories/%E7%94%9F%E6%B4%BB/%E9%A9%BE%E9%A9%B6/"},{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Shell","slug":"学习/Shell","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Shell/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"ACP","slug":"学习/ACP","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/ACP/"},{"name":"Office","slug":"学习/Office","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Office/"},{"name":"Linux","slug":"学习/Linux","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Linux/"},{"name":"迁移文章","slug":"迁移文章","permalink":"https://skinyi.github.io/categories/%E8%BF%81%E7%A7%BB%E6%96%87%E7%AB%A0/"},{"name":"杂项","slug":"学习/杂项","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"记分","slug":"记分","permalink":"https://skinyi.github.io/tags/%E8%AE%B0%E5%88%86/"},{"name":"驾照","slug":"驾照","permalink":"https://skinyi.github.io/tags/%E9%A9%BE%E7%85%A7/"},{"name":"开车","slug":"开车","permalink":"https://skinyi.github.io/tags/%E5%BC%80%E8%BD%A6/"},{"name":"法律法规","slug":"法律法规","permalink":"https://skinyi.github.io/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://skinyi.github.io/tags/Shell/"},{"name":"Bash","slug":"Bash","permalink":"https://skinyi.github.io/tags/Bash/"},{"name":"脚本编程","slug":"脚本编程","permalink":"https://skinyi.github.io/tags/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"},{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"认证考试","slug":"认证考试","permalink":"https://skinyi.github.io/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"},{"name":"ACP","slug":"ACP","permalink":"https://skinyi.github.io/tags/ACP/"},{"name":"云计算","slug":"云计算","permalink":"https://skinyi.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"阿里云","slug":"阿里云","permalink":"https://skinyi.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Excel","slug":"Excel","permalink":"https://skinyi.github.io/tags/Excel/"},{"name":"Office","slug":"Office","permalink":"https://skinyi.github.io/tags/Office/"},{"name":"避免加班","slug":"避免加班","permalink":"https://skinyi.github.io/tags/%E9%81%BF%E5%85%8D%E5%8A%A0%E7%8F%AD/"},{"name":"少加班","slug":"少加班","permalink":"https://skinyi.github.io/tags/%E5%B0%91%E5%8A%A0%E7%8F%AD/"},{"name":"RHEL","slug":"RHEL","permalink":"https://skinyi.github.io/tags/RHEL/"},{"name":"RHCE","slug":"RHCE","permalink":"https://skinyi.github.io/tags/RHCE/"},{"name":"Javascript","slug":"Javascript","permalink":"https://skinyi.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://skinyi.github.io/tags/Nodejs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://skinyi.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://skinyi.github.io/tags/Markdown/"}]}