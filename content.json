{"meta":{"title":"Avery Ma 的个人网站","subtitle":"这是什么？","description":"个人网站、博客","author":"skinyi","url":"https://skinyi.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-02-22T12:55:00.000Z","updated":"2022-02-24T13:30:42.633Z","comments":true,"path":"about/index.html","permalink":"https://skinyi.github.io/about/index.html","excerpt":"","text":"关于我 联系我 邮箱：averyma@foxmail.com"},{"title":"categories","date":"2022-02-23T06:19:06.228Z","updated":"2022-02-23T06:19:06.228Z","comments":false,"path":"categories/index.html","permalink":"https://skinyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"repositories","date":"2022-02-23T06:19:12.138Z","updated":"2022-02-23T06:19:12.138Z","comments":false,"path":"repository/index.html","permalink":"https://skinyi.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-23T06:19:18.235Z","updated":"2022-02-23T06:19:18.235Z","comments":false,"path":"tags/index.html","permalink":"https://skinyi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker Run 命令详解","slug":"Docker | Docker Run 命令详解","date":"2022-03-01T12:31:09.667Z","updated":"2022-03-01T14:56:34.064Z","comments":true,"path":"2022-03-01-Docker | Docker Run 命令详解.html","link":"","permalink":"https://skinyi.github.io/2022-03-01-Docker%20|%20Docker%20Run%20%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","excerpt":"","text":"Docker 在隔离的容器中运行进程。容器是在主机上运行的进程。主机可以是本地或远程的。当执行 docker run 时，运行的容器进程是独立的，因为它有自己的文件系统、自己的网络和自己的独立于主机的进程树。 以下介绍了如何在运行时使用 docker run 命令定义容器的资源。 docker run 命令的一般形式 基本的 docker run 命令采用以下形式： 1$ docker run [选项] IMAGE[:标签|@摘要] [命令] [参数...] docker run 命令必须指定从中生成容器的镜像。镜像开发人员可以定义与以下内容相关的镜像默认值： 分离或前台运行； 容器标识； 网络设置； 对CPU和内存的运行时约束。 通过 docker run [选项] 用户可以添加或覆盖开发人员设置的镜像默认值。此外，用户可以覆盖几乎所有由Docker 运行时本身设置的默认值。也正因为如此，docker run 比任何其他 Docker 命令都有更多选项。 根据你的 Docker 系统配置，你可能需要在 docker run 命令前面加上 sudo 以确保命令正常执行生效。为了避免在 docker 命令中使用 sudo，你的系统管理员可以创建一个名为 docker 的 Unix 组并向其中添加 docker 操作用户。 仅用户可指定的选项 仅执行 docker run 命令的用户可指定以下命令执行时的选项： 独立进程或前台执行 独立进程（-d 选项） 前台执行 容器标识 名称（--name 选项） PID equivalent IPC 设置（--ipc） 网络设置 重启策略（--restart） 清理（--rm） 运行时资源约束 运行时特权及 Linux capabilities 独立进程或前台执行 当启动了一个 Docker 容器，你必须先决定你是否想在后台以“分离”的模式或者默认在前台运行容器，可以使用 -d[=&lt;true|false&gt;] 选项来指定分离式模式，容器会在后台运行并打印出该容器的 id。 根据设计，当用于运行容器的根进程退出时，以分离模式启动的容器也会退出，除非你还指定了 -rm 选项。如果将 -d 与 -rm 一起使用，当容器退出或守护程序退出时(无论哪个先退出)，容器将被删除。 不要向分离模式运行的容器传递 service xxx start 的命令。如以下命令尝试创建容器后启动 nginx 服务。 1$ docker run -d -p 80:80 my_image service nginx start 即使这也会成功的启动容器内部的 nginx 服务，但是它不符合分离的容器范例，因为随着根进程（service nginx start）的退出，分离式容器也会跟着停止，从而导致 nginx 服务启动了却不能用。要启动一个进程如 nginx web 服务器应该按照下述方法： 1$ docker run -d -p 80:80 my_image nginx -g &#x27;daemon off;&#x27; 要使用分离的容器进行输入/输出则必须使用网络连接或共享卷，因为该容器不会监听运行 docker run 的命令行。 为了将分离出去的容器转至前台运行，可以使用 docker attach 命令。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"RHCE 考试及红帽企业 Linux 了解","slug":"Linux | RHCE 考试及红帽企业 Linux 了解","date":"2022-03-01T10:35:41.028Z","updated":"2022-03-01T11:52:32.996Z","comments":true,"path":"2022-03-01-Linux | RHCE 考试及红帽企业 Linux 了解.html","link":"","permalink":"https://skinyi.github.io/2022-03-01-Linux%20|%20RHCE%20%E8%80%83%E8%AF%95%E5%8F%8A%E7%BA%A2%E5%B8%BD%E4%BC%81%E4%B8%9A%20Linux%20%E4%BA%86%E8%A7%A3.html","excerpt":"","text":"🔴 此文章由之前的 Typora 笔记迁移过来，内容可能已经过时。 RHCE8.0 课程及考试代码 相较于 RHCE7 ，在 EX200 考试中，RHCE8 增加了 SHELL 脚本（RH254）、系统调优（RH442）以及 RHEL8 新特性的一些考察；在 EX294 考试中，RHCE7 考察一些常见的 Service 的搭建部署使用，如：NFS、SAMBA、DNS等，而在 RHCE8 考试中则主要考察 Ansible 自动化工具的操作，不再包含常见服务。 课程代码 考试代码 考试内容 考试形式 考试时长 RH124 EX200 以系统管理操作为主，如：文件系统、用户操作、权限操作、磁盘操作等 机考实验 2.5h RH134 RH294 EX294 全是关于 Ansible 自动化工具的技能操作 4h 搭建日常练习环境 🟢 所需前期准备工作： 已安装 VMWare Workstation 虚拟机，并在 bios 中开启了虚拟化相关的开关； 已下载好 RHEL8 Linux 操作系统 iso 镜像； 练习环境虚拟机以 NAT 模式和宿主机进行网络连接，使用的虚拟网卡是 VMNet8 。 虚拟机安装 RHEL8.3 操作系统 ​如图，虚拟机的配置如下，可根据自己个人硬件设备情况按需调整。 虚拟机软件选择如下： 设置 root 用户和普通用户后开始安装，等待进度条跑完重启虚拟机，重启后同意 Redhat 的 EULA，选择 FINISH CONFIGURATION 进入图形界面。图形界面默认为刚才创建的普通用户，新安装的 RHEL 还需要进行一些系统级的配置才行。 在此之前我们需要登陆 root 账户来配置我们新安装的操作系统。下图为使用 root 用户登陆后的界面。 安装完操作系统后的配置 配置网络设置 ​使用 ip addr show 命令来查看操作系统的网络配置结果如图所示： 🟢 其它网卡设备介绍： lo 虚拟网卡设备， lo 是主机用于向自身发送通信的一个特殊地址（也就是一个特殊的目的地址），其 ip 为 127.0.0.1 ； virbr0 是 KVM 默认创建的一个网桥，其作用是为连接其上的虚拟机网卡提供 NAT 访问外网的功能，可提供 DHCP 服务，其默认 ip 为 192.168.122.1。此虚拟设备被强制删除后重启系统还会再次创建，如需卸载须使用 KVM 虚拟化管理工具； birbr0-nic, 同上由 KVM 服务创建，可以使用 brctl 命令进行管理。 其中 ens160 才是连接外网所需要的网卡设备。可以看到此网卡没有绑定 ip 地址，但虚拟机软件是设置的 NAT 且已开启了 DHCP 服务，因此导致此问题的原因可能是我们的网卡设备没有启动或启用。需要检查此网卡设备的配置文件，其路径为：/etc/sysconfig/network-scripts/ifcfg-ens160（可以推断 RHEL 的网卡配置文件名称都是由 “ifcfg-” 和网卡名组成的），使用 vim 编辑器来编辑此文件，此文件内容如下： 123456789101112131415TYPE=Ethernet # 网络类型：以太网PROXY_METHOD=none # 网络代理方法BROWSER_ONLY=no BOOTPROTO=dhcp # 激活设备使用的地址配置协议：dhcp,static,none,bootpDEFROUTE=yes # ipv4 默认路由设备：yes,noIPV4_FAILURE_FATAL=noIPV6INIT=yes # 初始化 ipv6 协议栈：yes,noIPV6_AUTOCONF=yes # 自动配置 ipv6：yes,noIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens160 # 网卡名UUID=74e066fb-4f82-4422-ae3f-570dd2fca5a5 DEVICE=ens160 # 应用到的设备（和 HWADDR 必须留一个，后者指网卡物理地址）ONBOOT=no # 开机后自动激活此设备 🟢 Linux 网络配置说明： 网卡的相关配置文件：/etc/sysconfig/network-scripts/ifcfg-网卡名 路由相关的配置文件：/etc/sysconfig/network-scripts/route-网卡名 网络相关说明参考/usr/share/doc/initscripts-version/sysconfig.txt 需要将 ONBOOT=no 更改为 ONBOOT=yes 以使此网卡开机就激活启用，重启虚拟机，验证网卡是否已经自动激活（自动获得了 ip 地址则配置成功）。 使用 Xshell 远程登陆 ​在 Xshell 里新建连接，进行配置即可远程登陆到此虚拟机。 RHEL 和 CentOS 的区别 简称 中文全称 存在付费 付费回报 特点 RHEL 红帽企业 Linux 操作系统 是 获得技术支持 稳定，最先获得 Bug 修复 CentOS 社区企业操作系统 否 - 含有一些新特性，比较稳定，延迟获得 Bug 修复","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"学习/Linux","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Linux/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"迁移文章","slug":"迁移文章","permalink":"https://skinyi.github.io/categories/%E8%BF%81%E7%A7%BB%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"RHEL","slug":"RHEL","permalink":"https://skinyi.github.io/tags/RHEL/"},{"name":"认证考试","slug":"认证考试","permalink":"https://skinyi.github.io/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"}]},{"title":"Docker 命令手册及常用帮助命令","slug":"Docker | Docker 命令手册及常用帮助命令","date":"2022-02-27T14:03:20.637Z","updated":"2022-03-01T13:16:25.044Z","comments":true,"path":"2022-02-27-Docker | Docker 命令手册及常用帮助命令.html","link":"","permalink":"https://skinyi.github.io/2022-02-27-Docker%20|%20Docker%20%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"常用命令速查表格 命令 用途 docker version 查看 docker 客户端及服务端（docker 引擎）的版本及环境信息 docker info 查看 docker 的系统信息，包括客户端、服务端配置、镜像与容器数量以及一些其他常见配置 docker [命令] --help 查看 docker [命令] 使用的帮助信息，比如 docker image --help Docker 命令速查手册地址：https://docs.docker.com/engine/reference/run/ 。 常用帮助命令介绍 docker version 查看 docker 版本信息 12345678910111213141516171819202122232425262728293031[skinyi@fedora ~]\\$ sudo docker version[sudo] skinyi 的密码：Client: Docker Engine - Community Version: 20.10.12 API version: 1.41 Go version: go1.16.12 Git commit: e91ed57 Built: Mon Dec 13 11:46:03 2021 OS/Arch: linux/amd64 Context: default Experimental: trueServer: Docker Engine - Community Engine: Version: 20.10.12 API version: 1.41 (minimum version 1.12) Go version: go1.16.12 Git commit: 459d0df Built: Mon Dec 13 11:43:48 2021 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.4.12 GitCommit: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc: Version: 1.0.2 GitCommit: v1.0.2-0-g52b36a2 docker-init: Version: 0.19.0 GitCommit: de40ad0 docker info 查看 docker 的系统信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[skinyi@fedora ~]\\$ sudo docker info[sudo] skinyi 的密码：Client: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Docker Buildx (Docker Inc., v0.7.1-docker) scan: Docker Scan (Docker Inc., v0.12.0)Server: Containers: 2 Running: 0 Paused: 0 Stopped: 2 Images: 1 Server Version: 20.10.12 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: true userxattr: false Logging Driver: json-file Cgroup Driver: systemd Cgroup Version: 2 Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc io.containerd.runc.v2 io.containerd.runtime.v1.linux Default Runtime: runc Init Binary: docker-init containerd version: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc version: v1.0.2-0-g52b36a2 init version: de40ad0 Security Options: seccomp Profile: default cgroupns Kernel Version: 5.16.8-200.fc35.x86_64 Operating System: Fedora Linux 35 (Server Edition) OSType: linux Architecture: x86_64 CPUs: 2 Total Memory: 3.788GiB Name: fedora ID: I5R6:5NIE:OTIL:XBI4:R6WP:5XSO:BZTG:QGV6:6RHG:OU7U:P3EP:JTEC Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false docker [命令] --help 查看 docker [命令] 的帮助信息 123456789101112131415161718192021[skinyi@fedora ~]\\$ docker image --helpUsage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGERun &#x27;docker image COMMAND --help&#x27; for more information on a command. 123456789101112131415161718[skinyi@fedora ~]$ sudo docker container list --helpUsage: docker container ls [OPTIONS]List containersAliases: ls, ps, listOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don&#x27;t truncate output -q, --quiet Only display container IDs -s, --size Display total file sizes docker 子命令功能简介 子命令 描述 docker attach 将本地标准输入输出和错误流附加到正在运行的容器 docker build 从 Dockerfile 构建一个镜像 docker builder 管理镜像构建器 docker checkpoint 管理检查点 docker commit 从一个容器的所有更改创建一个新的镜像 docker config 管理 Docker 的配置 docker container 管理容器 docker context 管理 docker 上下文 docker cp 在容器和本地存储之间拷贝文件或目录 docker create 创建一个新的容器 docker diff 监视容器上的文件或目录的变化 docker events 从 docker 守护服务上获取实时事件 docker exec 在一个运行的容器上运行命令 docker export 将一个容器的文件系统以 tar 包的形式导出 docker history 展示一个镜像的提交历史 docker image 管理 docker 镜像 docker images 列出镜像 docker import 从 tar 包中导入内容来创建一个文件系统镜像 docker info 显示系统范围的信息 docker inspect 返回 docker 对象的底层信息 docker kill 杀掉一个或多个运行中的容器 docker load 从一个 tar 包或标准输入来加载镜像 docker login 登录 Docker registry docker logout 登出 Docker registry docker logs 获取一个容器的日志 docker manifest 管理 Docker 镜像清单和清单列表","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"Docker 介绍以及安装与卸载","slug":"Docker | Docker 介绍以及安装与卸载","date":"2022-02-27T13:03:47.405Z","updated":"2022-03-01T10:55:48.157Z","comments":true,"path":"2022-02-27-Docker | Docker 介绍以及安装与卸载.html","link":"","permalink":"https://skinyi.github.io/2022-02-27-Docker%20|%20Docker%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html","excerpt":"","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的 Linux 或 Windows 操作系统的机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 Docker 官方文档地址：https://docs.docker.com/。在其官网上关于 docker 的整体架构介绍可以找到这张图： 可以看出 docker 整体是模块化、低耦合且遵循 C/S 架构的，构成它的是功能不同的组件，以下是对这些组件的功能的梳理。 Docker 组件介绍 Docker Daemon：Docker 守护进程（dockerd）监听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和存储卷。守护进程还可以与其他守护进程通信以管理 Docker 服务。 Docker Client：Docker 客户端（docker）是许多 Docker 用户与 Docker 交互的主要方式。当你使用 docker run 等命令时，客户端会将这些命令发送给 dockerd，dockerd 会执行这些命令。 docker 命令使用 Docker API。Docker 客户端可以与多个守护进程通信。 Docker Desktop：是一个易于安装的应用程序，适用于 Mac 或 Windows 环境，能够构建和共享容器化应用程序和微服务。Docker Desktop 包括 Docker 守护程序 (dockerd)、Docker 客户端 (docker)、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。有关更多信息，请参阅 Docker 桌面。 Docker Registries：Docker 仓库存储 Docker 映像（Docker Image）。DockerHub 是一个任何人都可以使用的公共仓库，并且 Docker 默认配置为在 DockerHub 上查找镜像。甚至可以定制运行自己的私有仓库。 当使用 docker pull 或 docker run 命令时，将从系统所配置的镜像仓库中提取所需的镜像。当使用 docker push 命令时，你定制的镜像会被推送到你配置的镜像仓库中。 Docker Objects：当使用 Docker 时，会涉及到创建和使用图像、容器、网络、卷、插件和其他对象。以下简要概述其中一些对象。 Docker Image Docker 镜像是一个只读模板，其中包含创建 Docker 容器时的说明。通常，一个镜像基于另一个镜像，并附带有一些额外的自定义。例如，可以构建一个基于 ubuntu 镜像的镜像，但会安装 Apache Web 服务器和一些你的应用程序，该镜像还包含使你的应用程序运行所需的配置的详细信息。 你可以创建自己的镜像，也可以只使用其他人创建并在仓库中发布的镜像。要构建你自己的镜像，你需要使用简单的语法创建一个 Dockerfile，用于定义创建和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层。当你更改 Dockerfile 并重建映像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻量、小巧和快速的部分原因。 Docker Container Docker 容器是镜像的可运行实例。你可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。你可以将容器连接到一个或多个网络，将存储附加到它，甚至可以根据其当前状态创建新的镜像。 默认情况下，一个容器与其他容器以及其宿主机的隔离相对较好。你可以控制容器的网络、存储和其他底层子系统与其他容器或宿主机的隔离程度。 一个容器由其镜像以及你在创建或启动它时提供给它的任何配置选项进行定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。 ​Docker 三大核心组件指的是：Docker Image、Docker Container 以及 Docker Registry。 Docker 运行示例 以下命令运行 ubuntu 容器，以交互方式附加到本地命令行会话，并运行 /bin/bash。 1[skinyi@fedora ~]\\$ sudo docker run -i -t ubuntu /bin/bash ^ 安装 Docker 后如不做其他配置则 docker run 命令只能使用 root 权限来执行。 当你运行此命令时，会发生以下情况（假设你使用的是默认镜像仓库配置）： 如果你在本地没有 ubuntu 映像，Docker 会从你配置的镜像仓库（默认 DockerHub）中提取它，就像你手动运行 docker pull ubuntu 一样； Docker 使用该镜像创建一个新容器，就像你手动运行了 docker container create 命令一样； Docker 为该容器分配一个读写文件系统，作为该容器的底层，这允许正在运行的容器在其本地文件系统中创建或修改文件和目录； 由于没有指定任何其他的网络选项，Docker 会创建一个网络接口来将该容器连接到默认网络，包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。 Docker 启动容器并执行 /bin/bash。由于容器以交互方式运行并附加到您的终端（-i 和 -t 选项），所以你可以在将输出记录到终端时使用键盘提供输入。 当你键入 exit 命令以终止 /bin/bash 命令时，容器会停止但不会被删除，你可以重新启动或删除它。 Docker 的安装与卸载 个人学习使用操作系统为：Fedora 35，Fedora 版本目前仅支持 Fedora 34 和 Fedora 35。 12345678910111213141516171819202122[skinyi@fedora ~]\\$ cat /etc/os-releaseNAME=&quot;Fedora Linux&quot;VERSION=&quot;35 (Server Edition)&quot;ID=fedoraVERSION_ID=35VERSION_CODENAME=&quot;&quot;PLATFORM_ID=&quot;platform:f35&quot;PRETTY_NAME=&quot;Fedora Linux 35 (Server Edition)&quot;ANSI_COLOR=&quot;0;38;2;60;110;180&quot;LOGO=fedora-logo-iconCPE_NAME=&quot;cpe:/o:fedoraproject:fedora:35&quot;HOME_URL=&quot;https://fedoraproject.org/&quot;DOCUMENTATION_URL=&quot;https://docs.fedoraproject.org/en-US/fedora/f35/system-administrators-guide/&quot;SUPPORT_URL=&quot;https://ask.fedoraproject.org/&quot;BUG_REPORT_URL=&quot;https://bugzilla.redhat.com/&quot;REDHAT_BUGZILLA_PRODUCT=&quot;Fedora&quot;REDHAT_BUGZILLA_PRODUCT_VERSION=35REDHAT_SUPPORT_PRODUCT=&quot;Fedora&quot;REDHAT_SUPPORT_PRODUCT_VERSION=35PRIVACY_POLICY_URL=&quot;https://fedoraproject.org/wiki/Legal:PrivacyPolicy&quot;VARIANT=&quot;Server Edition&quot;VARIANT_ID=server Fedora 操作系统 Docker 安装文档：https://docs.docker.com/engine/install/fedora/。 卸载旧版本 12345678[skinyi@fedora ~]\\$ sudo dnf remove docker \\ docker-client \\ docker-client-lastest \\ docker-common \\ docker-lastest-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 使用软件仓库进行 Doker 的安装 ​安装 dnf-plugins-core 插件。 1[skinyi@fedora ~]$ sudo dnf -y install dnf-plugins-core ​添加 docker 的官方软件仓库。 12[skinyi@fedora ~]$ sudo dnf config-manager --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo 安装 Docker 引擎 1[skinyi@fedora ~]$ sudo dnf install docker-ce docker-ce-cli containerd.io 启动并验证 Docker 是否成功安装 1234567891011121314151617181920212223[skinyi@fedora ~]$ sudo systemctl start docker[skinyi@fedora ~]$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 实现非 root 权限执行 docker 命令或者实现一些其他安装后的优化可以参阅：https://docs.docker.com/engine/install/linux-postinstall/。 卸载 Docker 引擎 12[skinyi@fedora ~]$ sudo dnf remove docker-ce docker-ce-cli containerd.io[skinyi@fedora ~]$ sudo rm -rf /var/lib/docker /var/lib/containerd 启动 Docker 时的执行过程 启动过程中的注意点： Docker 优先使用的存储驱动为 Overlay2； 加载容器时会设置容器的网络，并创建虚拟网络接口 docker0，该接口使用桥接模式接入网络，并在宿主机防火墙中配置一个 docker zone； Docker 的守护程序 dockerd 初始化成功后会启动 docker 应用容器引擎，然后 docker 引擎通过监听 /run/docker.sock 套接字实现客户端与守护程序之间的通信。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"使用 Hexo 搭建个人博客","slug":"Hexo | 使用 Hexo 搭建个人博客","date":"2022-02-21T14:23:11.437Z","updated":"2022-03-01T12:23:53.488Z","comments":true,"path":"2022-02-21-Hexo | 使用 Hexo 搭建个人博客.html","link":"","permalink":"https://skinyi.github.io/2022-02-21-Hexo%20|%20%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html","excerpt":"","text":"一直以来都有搭建个人网站或者说博客的想法，今天终于把这件事做成了，感谢 Github 各大代码托管平台的 GitHub XXX Pages 服务，使我们即使没有公网服务器也能搭个人人可访问的静态个人网站，而且无需任何费用。当然国内码云也有这项服务，由于一些理由我没有在那上面弄， Github Pages 由于国内访问速度太慢了，我就在码云上面也创建了仓库，然而启用 Pages 功能需要实名认证。言归正传，按照 Hexo 社区的惯例以及正好作为自己对搭建个人网站过程的记录，我的个人网站上的第一篇文章就打算写写这个搭建博客的过程。 准备工作 搭建博客所需的环境和官网地址如下： 名称 作用 官网 Nodejs Hexo 博客框架依赖的开发环境 https://nodejs.org/en/ Git 推送博客至 github 或其他一些代码托管 https://git-scm.com/ Hexo 快速、简洁且高效的博客框架 https://hexo.io/zh-cn/ Purer theme 一款简洁高效的响应式个人博客主题 https://github.com/fengkx/hexo-theme-purer 博客系统平台环境搭建在我的 Fedora 35 虚拟机上。 12[skinyi@localhost ~]$ uname -aLinux localhost.localdomain 5.16.9-200.fc35.x86_64 #1 SMP PREEMPT Fri Feb 11 16:29:17 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux 安装步骤 我非常建议你按照我上面所给的表格来访问官方文档来分步进行部署。官方文档永远不会过时而且详尽，会最大程度上解决你的疑虑。以下是我对此次部署过程的一次记录，其中会着重记录我的部署过程中踩过的一些坑。 安装 Nodejs 使用 Linux 系统我个人比较倾向于从软件仓库获得软件，但是软件仓库里的软件不一定会是最新版的，但是这种方式可以使我们省去自己编译、配置的时间。Nodejs 官网上的下载页面里的 Linux 二进制版本是压缩包，要从软件仓库获得它的话需要点击下面的 Installing Node.js via package manager 链接来查阅官方文档。 根据文档的描述，Fedora 35 可以通过安装 dnf 软件模块的方式来进行安装，可以先看看仓库里已有的软件流版本： 1234567891011121314151617[skinyi@localhost ~]$ dnf module list nodejs上次元数据过期检查：0:08:01 前，执行于 2022年02月23日 星期三 18时50分04秒。Fedora Modular 35 - x86_64Name Stream Profiles Summary nodejs 12 default, development, minimal Javascript runtime nodejs 14 default, development, minimal Javascript runtime nodejs 15 default, development, minimal Javascript runtime nodejs 16 default, development, minimal Javascript runtime Fedora Modular 35 - x86_64 - UpdatesName Stream Profiles Summary nodejs 12 default, development, minimal Javascript runtime nodejs 14 common, development, minimal Javascript runtime nodejs 15 default, development, minimal Javascript runtime nodejs 16 [e] common, development, minimal Javascript runtime 提示：[d]默认，[e]已启用，[x]已禁用，[i]已安装 Hexo 官方文档中建议 Nodejs 版本使用 Nodejs 12.0 及以上版本的，在这里我选择安装 Nodejs 16 版本的。 1[skinyi@localhost ~]$ sudo dnf module install nodejs:16 安装完成后查看 Nodejs 版本号： 12[skinyi@localhost ~]$ node -vv16.14.0 从仓库安装完成后，需要升级 npm 版本以及为了不用以 root 权限执行 npm 命令，需要更改 npm 的配置： 1234# 在当前用户主目录创建 npm 全局安装目录[skinyi@localhost ~]$ mkdir ~/.npm-global# 配置 npm 使用刚才建的目录路径[skinyi@localhost ~]$ npm config set prefix &#x27;~/.npm-global&#x27; 添加 ~/.npm-global/bin 路径到用户环境变量： 12[skinyi@localhost ~]$ echo &#x27;export PATH=~/.npm-global/bin:$PATH&#x27; &gt;&gt; ~/.bash_rc[skinyi@localhost ~]$ source ~/.bash_rc 安装Git 使用 dnf 包管理器安装 Git： 1[skinyi@localhost ~]$ sudo dnf install git-core git 全局配置，如果需要通过 git 将博客部署到 Github Pages 上，需要配置 git 的一些全局设置： 12[skinyi@localhost ~]$ git config --global user.name &quot;github 上的用户名&quot;[skinyi@localhost ~]$ git config --global user.email &quot;注册 github 账号使用的邮箱&quot; 安装 Hexo 以上依赖软件安装成功后，就可以进行 Hexo 的安装了： 1[skinyi@localhost ~]$ npm install -g hexo-cli 在工作目录里初始化自己的博客项目： 1234[skinyi@localhost ~]$ hexo init blog[skinyi@localhost ~]$ cd blog[skinyi@localhost ~]$ npm install[skinyi@localhost ~]$ hexo server 可以通过浏览器访问本地地址：http://127.0.0.1:4000 来预览生成的博客网站，若要在外部访问的话需要通过防火墙开放 4000 端口，在此不再赘述。 更换博客主题 从 Hexo 主题列表里筛选了一圈后我终于选中了此时用的这款主题，它的 Github 链接是：https://github.com/fengkx/hexo-theme-purer ，如果你也喜欢这款主题，可以通过项目主页的的说明文档来了解它的安装、配置及使用，不过建议你在看作者的文档前先大致看下 Hexo 的使用文档来了解了解 Hexo 的一些基本概念，这样看作者的文档再上手就比较容易了。 这款主题是基于 EJS 和 Tailwind CSS 构建的，以后若有兴趣构建自己的主题可以参考使用这两种技术。 下载主题文件 我没有按照官方使用 git clone 同步的方法来下载主题，直接通过下载仓库源码的方式下载下来。gh-pages 是我的整个博客项目的主目录。 123[skinyi@localhost gh-pages]$ wget -c https://github.com/fengkx/hexo-theme-purer/archive/refs/heads/master.zip -O themes/[skinyi@localhost gh-pages]$ unzip themes/master.zip[skinyi@localhost gh-pages]$ mv themes/hexo-theme-purer-master themes/purer 文档中为了避免由于主题更新而导致原有的主题目录下的 _config.yml 文件失效故而选择把主题的 _config.yml 放在主题外面并取名为 _config.theme.yml，在进行编译时将此文件的内容写进主题底下的 _config.yml。虽然我之后不会更新这个主题但是我还是按照文档里的做了，只不过我起的名字为 _config.purer.yml。 将 purer 主题下的 _config.example.yml 复制到项目主目录下。然后编辑 package.json 的内容如下： 12[skinyi@localhost gh-pages]$ cp themes/purer/_config.example.yml _config.purer.yml[skinyi@localhost gh-pages]$ code package.json package.json123456789&#123; &quot;scripts&quot;: &#123; &quot;theme&quot;: &quot;cat ./_config.purer.yml &gt; ./themes/purer/_config.yml &quot;, &quot;build&quot;: &quot;npm run theme &amp;&amp; hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;npm run theme &amp;&amp; hexo deploy&quot;, &quot;server&quot;: &quot;npm run theme &amp;&amp; hexo server&quot; &#125;,&#125; 配置主题 安装及配置插件 首先可选的工作是卸载不需要或不推荐的渲染器： 12[skinyi@localhost gh-pages]$ npm uninstall hexo-renderer-stylus[skinyi@localhost gh-pages]$ npm uninstall hexo-renderer-marked 安装 markdown-it 渲染器以及其他常用插件： 12345678# markdown-it 渲染器[skinyi@localhost gh-pages]$ npm i -S hexo-renderer-markdown-it# 支持从post_assert_folder 用 markdown 引入图片[skinyi@localhost gh-pages]$ npm i -S hexo-asset-image# 支持 emoji[skinyi@localhost gh-pages]$ npm i -S markdown-it-emoji# 支持数学公式[skinyi@localhost gh-pages]$ npm i -S @iktakahiro/markdown-it-katex 由于 hexo-renderer-markdown-it 默认不生成 h1 的锚点，所以我们需要在站点配置文件添加如下设置，在插件对象里将刚才添加的两个插件加进去: _config.yml123456789101112131415markdown: html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ anchors: level: 1 permalink: false separator: &#x27;-&#x27; plugins: - &#x27;@iktakahiro/markdown-it-katex&#x27; - markdown-it-emoji 创建常见页面 在 项目主目录/source 下按需添加 categories、tags、repositories、links、about 目录，这些分别对应博客框架中的分类页、标签页、仓库页（主题独有）、友链页、关于页。然后在其中创建对应的 index.md 文件。 我的项目没有要友链页，故最终目录结构如下： 12345678910111213141516171819[skinyi@localhost gh-pages]$ tree -L 2 sourcesource├── about│ └── index.md├── categories│ └── index.md├── images│ ├── avatar.jpg│ └── favicon.png├── _posts│ ├── 使用 Hexo 搭建个人博客.md│ └── images├── README.md├── repository│ └── index.md└── tags └── index.md7 directories, 8 files 如果你事先看过 Hexo 的文档，你就会知道 _post 目录存放的是写好的文章以及我们刚刚创建的 index.md 需要添加 front-matter。以内容稍微多的 about 目录的 front-matter 为例： 1234567---title: 关于description: 个人简介layout: aboutsidebar: customdate: 2022-02-22 20:55:00--- 其他目录的 front-matter 可以参考主题作者文档中的 Demo 链接。 定制主题配置 接下来需要修改项目主目录下的 _config_purer.yml 文件来定制自己的主题，这个参照主题文档按照自己的心意定制就成，我没有要友链和书单页面。 写作 所有已经发表的文章都在项目目录的 source/_posts 子目录下，Hexo 同样支持添加草稿，草稿目录里的文章默认不会渲染出来。对我来说懒得使用草稿了，因为吹牛根本不需要打草稿。我比较喜欢 VSCode 里边写边想，写完后再部署就可以了，根本不需要草稿。 博文是以 markdown 格式编写的，好在这门语言的学习成本并不高，多写多用多记就可以满足大部分使用需要，比较冷门的格式需要用的时候再查也花费不了太长时间。 部署文章 博客网站搭建起来了需要部署到公网上才能被他人看到，但是公网 IP 以及服务器需要花费不小的经济成本，好在一些代码托管网站都提供了 XXX Pages 服务。需要注意的是：在国内的平台上启用 Pages 服务一般都需要进行实名认证，而在 Github Pages 上部署不需要进行实名。 使用 git 的方式进行博客部署可以安装 hexo 插件 hexo-deployer-git： 1[skinyi@localhost gh-pages]$ npm install hexo-deployer-git --save 在 _config.yml 中修改配置： 1234567deploy: type: git repo: github: &lt;github 仓库地址&gt; # 如 https://github.com/xxx/xxx.github.io gitee: &lt;gitee 仓库地址&gt; # 如 https://gitee.com/xxx/xxx branch: [代码分支] # 如 master message: [提交信息] 生成站点文件并推送至远程仓库： 1[skinyi@localhost gh-pages]$ hexo clean &amp;&amp; hexo deploy 通过 Git 方式提交时建议在本地生成公私钥对并将生成的公钥文件添加到远程仓库的公钥列表里，然后每次提交时就可以通过验证公私密钥对的方式而不用每次都输用户名及密码。 到这里基本算是介绍完了所有的搭建步骤，之后我会把我在 Typora 里写的所有学习笔记都搬运到这个博客中，当然这个网站的内容并不局限于一些跟技术相关的东西，我并不确定我写的这些东西会不会有人看，我也打算写一些技术博客以外的东西，不管以后怎么样、写些什么，就活在当下、享受并记录生活吧。","categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"杂项","slug":"学习/杂项","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://skinyi.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://skinyi.github.io/tags/Nodejs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://skinyi.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://skinyi.github.io/tags/Markdown/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"学习/Docker","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"日常记录","slug":"日常记录","permalink":"https://skinyi.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"Linux","slug":"学习/Linux","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/Linux/"},{"name":"迁移文章","slug":"迁移文章","permalink":"https://skinyi.github.io/categories/%E8%BF%81%E7%A7%BB%E6%96%87%E7%AB%A0/"},{"name":"杂项","slug":"学习/杂项","permalink":"https://skinyi.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://skinyi.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://skinyi.github.io/tags/Linux/"},{"name":"容器","slug":"容器","permalink":"https://skinyi.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://skinyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"RHEL","slug":"RHEL","permalink":"https://skinyi.github.io/tags/RHEL/"},{"name":"认证考试","slug":"认证考试","permalink":"https://skinyi.github.io/tags/%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"},{"name":"Javascript","slug":"Javascript","permalink":"https://skinyi.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://skinyi.github.io/tags/Nodejs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://skinyi.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://skinyi.github.io/tags/Markdown/"}]}